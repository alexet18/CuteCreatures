{"ast":null,"code":"import * as i2 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport * as i1$2 from '@angular/cdk/scrolling';\nimport { CdkVirtualScrollViewport, ScrollingModule } from '@angular/cdk/scrolling';\nimport * as i1$1 from '@angular/common';\nimport { CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Component, ChangeDetectionStrategy, Input, Output, Host, Optional, Directive, Inject, ViewEncapsulation, ViewChild, NgModule } from '@angular/core';\nimport * as i1 from 'ng-zorro-antd/core/no-animation';\nimport { NzNoAnimationModule } from 'ng-zorro-antd/core/no-animation';\nimport { __decorate } from 'tslib';\nimport { InputBoolean } from 'ng-zorro-antd/core/util';\nimport { Subject, animationFrameScheduler, asapScheduler, merge, BehaviorSubject } from 'rxjs';\nimport { takeUntil, auditTime, take, map } from 'rxjs/operators';\nimport { CdkTreeNode, CdkTree, CdkTreeNodeToggle, CdkTreeNodeDef, CDK_TREE_NODE_OUTLET_NODE, CdkTreeNodeOutlet, CdkTreeNodePadding, CdkTreeNodeOutletContext } from '@angular/cdk/tree';\nimport { coerceBooleanProperty } from '@angular/cdk/coercion';\nimport { treeCollapseMotion } from 'ng-zorro-antd/core/animation';\nimport { DataSource } from '@angular/cdk/collections';\n\nfunction NzTreeNodeIndentsComponent_span_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"span\", 1);\n  }\n\n  if (rf & 2) {\n    const isEnd_r1 = ctx.$implicit;\n    i0.ɵɵclassProp(\"ant-tree-indent-unit-end\", !isEnd_r1);\n  }\n}\n\nfunction NzTreeNodeComponent_nz_tree_node_indents_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"nz-tree-node-indents\", 2);\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵproperty(\"indents\", ctx_r0.indents);\n  }\n}\n\nfunction NzTreeNodeComponent_nz_tree_node_toggle_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"nz-tree-node-toggle\", 3);\n    i0.ɵɵelement(1, \"span\", 4);\n    i0.ɵɵelementEnd();\n  }\n}\n\nconst _c0 = [[[\"nz-tree-node-toggle\"], [\"\", \"nz-tree-node-toggle\", \"\"]], [[\"nz-tree-node-checkbox\"]], [[\"nz-tree-node-option\"]], \"*\"];\nconst _c1 = [\"nz-tree-node-toggle, [nz-tree-node-toggle]\", \"nz-tree-node-checkbox\", \"nz-tree-node-option\", \"*\"];\nconst _c2 = [\"*\"];\n\nfunction NzTreeVirtualScrollViewComponent_ng_container_2_ng_template_1_Template(rf, ctx) {}\n\nfunction NzTreeVirtualScrollViewComponent_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, NzTreeVirtualScrollViewComponent_ng_container_2_ng_template_1_Template, 0, 0, \"ng-template\", 4);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const item_r1 = ctx.$implicit;\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"data\", item_r1);\n  }\n}\n\nlet NzTreeNodeCheckboxComponent = /*#__PURE__*/(() => {\n  class NzTreeNodeCheckboxComponent {\n    constructor() {\n      this.nzClick = new EventEmitter();\n    }\n\n    onClick(e) {\n      if (!this.nzDisabled) {\n        this.nzClick.emit(e);\n      }\n    }\n\n  }\n\n  NzTreeNodeCheckboxComponent.ɵfac = function NzTreeNodeCheckboxComponent_Factory(t) {\n    return new (t || NzTreeNodeCheckboxComponent)();\n  };\n\n  NzTreeNodeCheckboxComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NzTreeNodeCheckboxComponent,\n    selectors: [[\"nz-tree-node-checkbox\", 3, \"builtin\", \"\"]],\n    hostAttrs: [1, \"ant-tree-checkbox\"],\n    hostVars: 6,\n    hostBindings: function NzTreeNodeCheckboxComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function NzTreeNodeCheckboxComponent_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"ant-tree-checkbox-checked\", ctx.nzChecked)(\"ant-tree-checkbox-indeterminate\", ctx.nzIndeterminate)(\"ant-tree-checkbox-disabled\", ctx.nzDisabled);\n      }\n    },\n    inputs: {\n      nzChecked: \"nzChecked\",\n      nzIndeterminate: \"nzIndeterminate\",\n      nzDisabled: \"nzDisabled\"\n    },\n    outputs: {\n      nzClick: \"nzClick\"\n    },\n    decls: 1,\n    vars: 0,\n    consts: [[1, \"ant-tree-checkbox-inner\"]],\n    template: function NzTreeNodeCheckboxComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelement(0, \"span\", 0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([InputBoolean()], NzTreeNodeCheckboxComponent.prototype, \"nzDisabled\", void 0);\n\n  return NzTreeNodeCheckboxComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nconst getParent = (nodes, node, getLevel) => {\n  let index = nodes.indexOf(node);\n\n  if (index < 0) {\n    return null;\n  }\n\n  const level = getLevel(node);\n\n  for (index--; index >= 0; index--) {\n    const preLevel = getLevel(nodes[index]);\n\n    if (preLevel + 1 === level) {\n      return nodes[index];\n    }\n\n    if (preLevel + 1 < level) {\n      return null;\n    }\n  }\n\n  return null;\n};\n\nconst getNextSibling = (nodes, node, getLevel, _index) => {\n  let index = typeof _index !== 'undefined' ? _index : nodes.indexOf(node);\n\n  if (index < 0) {\n    return null;\n  }\n\n  const level = getLevel(node);\n\n  for (index++; index < nodes.length; index++) {\n    const nextLevel = getLevel(nodes[index]);\n\n    if (nextLevel < level) {\n      return null;\n    }\n\n    if (nextLevel === level) {\n      return nodes[index];\n    }\n  }\n\n  return null;\n};\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nclass NzNodeBase extends CdkTreeNode {} // eslint-disable-next-line @angular-eslint/component-class-suffix\n\n\nlet NzTreeView = /*#__PURE__*/(() => {\n  class NzTreeView extends CdkTree {\n    constructor(differs, changeDetectorRef, noAnimation, directionality) {\n      super(differs, changeDetectorRef);\n      this.differs = differs;\n      this.changeDetectorRef = changeDetectorRef;\n      this.noAnimation = noAnimation;\n      this.directionality = directionality;\n      this.destroy$ = new Subject();\n      this.dir = 'ltr';\n      this._dataSourceChanged = new Subject();\n      this.nzDirectoryTree = false;\n      this.nzBlockNode = false;\n    }\n\n    get dataSource() {\n      return super.dataSource;\n    }\n\n    set dataSource(dataSource) {\n      super.dataSource = dataSource;\n    }\n\n    ngOnInit() {\n      var _a;\n\n      super.ngOnInit();\n\n      if (this.directionality) {\n        this.dir = this.directionality.value;\n        (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n          this.dir = direction;\n          this.changeDetectorRef.detectChanges();\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n    renderNodeChanges(data, dataDiffer, viewContainer, parentData) {\n      super.renderNodeChanges(data, dataDiffer, viewContainer, parentData);\n\n      this._dataSourceChanged.next();\n    }\n\n  }\n\n  NzTreeView.ɵfac = function NzTreeView_Factory(t) {\n    return new (t || NzTreeView)(i0.ɵɵdirectiveInject(i0.IterableDiffers), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.NzNoAnimationDirective, 9), i0.ɵɵdirectiveInject(i2.Directionality, 8));\n  };\n\n  NzTreeView.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NzTreeView,\n    selectors: [[\"ng-component\"]],\n    inputs: {\n      treeControl: [\"nzTreeControl\", \"treeControl\"],\n      dataSource: [\"nzDataSource\", \"dataSource\"],\n      nzDirectoryTree: \"nzDirectoryTree\",\n      nzBlockNode: \"nzBlockNode\"\n    },\n    features: [i0.ɵɵInheritDefinitionFeature],\n    decls: 0,\n    vars: 0,\n    template: function NzTreeView_Template(rf, ctx) {},\n    encapsulation: 2\n  });\n\n  __decorate([InputBoolean()], NzTreeView.prototype, \"nzDirectoryTree\", void 0);\n\n  __decorate([InputBoolean()], NzTreeView.prototype, \"nzBlockNode\", void 0);\n\n  return NzTreeView;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * [true, false, false, true] => 1001\n */\n\n\nfunction booleanArrayToString(arr) {\n  return arr.map(i => i ? 1 : 0).join('');\n}\n\nconst BUILD_INDENTS_SCHEDULER = typeof requestAnimationFrame !== 'undefined' ? animationFrameScheduler : asapScheduler;\nlet NzTreeNodeIndentsComponent = /*#__PURE__*/(() => {\n  class NzTreeNodeIndentsComponent {\n    constructor() {\n      this.indents = [];\n    }\n\n  }\n\n  NzTreeNodeIndentsComponent.ɵfac = function NzTreeNodeIndentsComponent_Factory(t) {\n    return new (t || NzTreeNodeIndentsComponent)();\n  };\n\n  NzTreeNodeIndentsComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NzTreeNodeIndentsComponent,\n    selectors: [[\"nz-tree-node-indents\"]],\n    hostAttrs: [1, \"ant-tree-indent\"],\n    inputs: {\n      indents: \"indents\"\n    },\n    decls: 1,\n    vars: 1,\n    consts: [[\"class\", \"ant-tree-indent-unit\", 3, \"ant-tree-indent-unit-end\", 4, \"ngFor\", \"ngForOf\"], [1, \"ant-tree-indent-unit\"]],\n    template: function NzTreeNodeIndentsComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, NzTreeNodeIndentsComponent_span_0_Template, 1, 2, \"span\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.indents);\n      }\n    },\n    directives: [i1$1.NgForOf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return NzTreeNodeIndentsComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NzTreeNodeIndentLineDirective = /*#__PURE__*/(() => {\n  class NzTreeNodeIndentLineDirective {\n    constructor(treeNode, tree, cdr) {\n      this.treeNode = treeNode;\n      this.tree = tree;\n      this.cdr = cdr;\n      this.isLast = 'unset';\n      this.isLeaf = false;\n      this.preNodeRef = null;\n      this.nextNodeRef = null;\n      this.currentIndents = '';\n      this.buildIndents();\n      this.checkLast();\n      /**\n       * The dependent data (TreeControl.dataNodes) can be set after node instantiation,\n       * and setting the indents can cause frame rate loss if it is set too often.\n       */\n\n      this.changeSubscription = merge(this.treeNode._dataChanges, tree._dataSourceChanged).pipe(auditTime(0, BUILD_INDENTS_SCHEDULER)).subscribe(() => {\n        this.buildIndents();\n        this.checkAdjacent();\n        this.cdr.markForCheck();\n      });\n    }\n\n    getIndents() {\n      const indents = [];\n      const nodes = this.tree.treeControl.dataNodes;\n      const getLevel = this.tree.treeControl.getLevel;\n      let parent = getParent(nodes, this.treeNode.data, getLevel);\n\n      while (parent) {\n        const parentNextSibling = getNextSibling(nodes, parent, getLevel);\n\n        if (parentNextSibling) {\n          indents.unshift(true);\n        } else {\n          indents.unshift(false);\n        }\n\n        parent = getParent(nodes, parent, getLevel);\n      }\n\n      return indents;\n    }\n\n    buildIndents() {\n      if (this.treeNode.data) {\n        const indents = this.getIndents();\n        const diffString = booleanArrayToString(indents);\n\n        if (diffString !== this.currentIndents) {\n          this.treeNode.setIndents(this.getIndents());\n          this.currentIndents = diffString;\n        }\n      }\n    }\n    /**\n     * We need to add an class name for the last child node,\n     * this result can also be affected when the adjacent nodes are changed.\n     */\n\n\n    checkAdjacent() {\n      const nodes = this.tree.treeControl.dataNodes;\n      const index = nodes.indexOf(this.treeNode.data);\n      const preNode = nodes[index - 1] || null;\n      const nextNode = nodes[index + 1] || null;\n\n      if (this.nextNodeRef !== nextNode || this.preNodeRef !== preNode) {\n        this.checkLast(index);\n      }\n\n      this.preNodeRef = preNode;\n      this.nextNodeRef = nextNode;\n    }\n\n    checkLast(index) {\n      const nodes = this.tree.treeControl.dataNodes;\n      this.isLeaf = this.treeNode.isLeaf;\n      this.isLast = !getNextSibling(nodes, this.treeNode.data, this.tree.treeControl.getLevel, index);\n    }\n\n    ngOnDestroy() {\n      this.preNodeRef = null;\n      this.nextNodeRef = null;\n      this.changeSubscription.unsubscribe();\n    }\n\n  }\n\n  NzTreeNodeIndentLineDirective.ɵfac = function NzTreeNodeIndentLineDirective_Factory(t) {\n    return new (t || NzTreeNodeIndentLineDirective)(i0.ɵɵdirectiveInject(NzNodeBase), i0.ɵɵdirectiveInject(NzTreeView), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  NzTreeNodeIndentLineDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NzTreeNodeIndentLineDirective,\n    selectors: [[\"nz-tree-node\", \"nzTreeNodeIndentLine\", \"\"]],\n    hostAttrs: [1, \"ant-tree-show-line\"],\n    hostVars: 2,\n    hostBindings: function NzTreeNodeIndentLineDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"ant-tree-treenode-leaf-last\", ctx.isLast && ctx.isLeaf);\n      }\n    }\n  });\n  return NzTreeNodeIndentLineDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzTreeNodeNoopToggleDirective = /*#__PURE__*/(() => {\n  class NzTreeNodeNoopToggleDirective {}\n\n  NzTreeNodeNoopToggleDirective.ɵfac = function NzTreeNodeNoopToggleDirective_Factory(t) {\n    return new (t || NzTreeNodeNoopToggleDirective)();\n  };\n\n  NzTreeNodeNoopToggleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NzTreeNodeNoopToggleDirective,\n    selectors: [[\"nz-tree-node-toggle\", \"nzTreeNodeNoopToggle\", \"\"], [\"\", \"nzTreeNodeNoopToggle\", \"\"]],\n    hostAttrs: [1, \"ant-tree-switcher\", \"ant-tree-switcher-noop\"]\n  });\n  return NzTreeNodeNoopToggleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NzTreeNodeToggleDirective = /*#__PURE__*/(() => {\n  class NzTreeNodeToggleDirective extends CdkTreeNodeToggle {\n    get recursive() {\n      return this._recursive;\n    }\n\n    set recursive(value) {\n      this._recursive = coerceBooleanProperty(value);\n    }\n\n    get isExpanded() {\n      return this._treeNode.isExpanded;\n    }\n\n  }\n\n  NzTreeNodeToggleDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵNzTreeNodeToggleDirective_BaseFactory;\n    return function NzTreeNodeToggleDirective_Factory(t) {\n      return (ɵNzTreeNodeToggleDirective_BaseFactory || (ɵNzTreeNodeToggleDirective_BaseFactory = i0.ɵɵgetInheritedFactory(NzTreeNodeToggleDirective)))(t || NzTreeNodeToggleDirective);\n    };\n  }();\n\n  NzTreeNodeToggleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NzTreeNodeToggleDirective,\n    selectors: [[\"nz-tree-node-toggle\", 3, \"nzTreeNodeNoopToggle\", \"\"], [\"\", \"nzTreeNodeToggle\", \"\"]],\n    hostAttrs: [1, \"ant-tree-switcher\"],\n    hostVars: 4,\n    hostBindings: function NzTreeNodeToggleDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"ant-tree-switcher_open\", ctx.isExpanded)(\"ant-tree-switcher_close\", !ctx.isExpanded);\n      }\n    },\n    inputs: {\n      recursive: [\"nzTreeNodeToggleRecursive\", \"recursive\"]\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: CdkTreeNodeToggle,\n      useExisting: NzTreeNodeToggleDirective\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return NzTreeNodeToggleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NzTreeNodeToggleRotateIconDirective = /*#__PURE__*/(() => {\n  class NzTreeNodeToggleRotateIconDirective {}\n\n  NzTreeNodeToggleRotateIconDirective.ɵfac = function NzTreeNodeToggleRotateIconDirective_Factory(t) {\n    return new (t || NzTreeNodeToggleRotateIconDirective)();\n  };\n\n  NzTreeNodeToggleRotateIconDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NzTreeNodeToggleRotateIconDirective,\n    selectors: [[\"\", \"nz-icon\", \"\", \"nzTreeNodeToggleRotateIcon\", \"\"]],\n    hostAttrs: [1, \"ant-tree-switcher-icon\"]\n  });\n  return NzTreeNodeToggleRotateIconDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NzTreeNodeToggleActiveIconDirective = /*#__PURE__*/(() => {\n  class NzTreeNodeToggleActiveIconDirective {}\n\n  NzTreeNodeToggleActiveIconDirective.ɵfac = function NzTreeNodeToggleActiveIconDirective_Factory(t) {\n    return new (t || NzTreeNodeToggleActiveIconDirective)();\n  };\n\n  NzTreeNodeToggleActiveIconDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NzTreeNodeToggleActiveIconDirective,\n    selectors: [[\"\", \"nz-icon\", \"\", \"nzTreeNodeToggleActiveIcon\", \"\"]],\n    hostAttrs: [1, \"ant-tree-switcher-loading-icon\"]\n  });\n  return NzTreeNodeToggleActiveIconDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzTreeNodeComponent = /*#__PURE__*/(() => {\n  class NzTreeNodeComponent extends NzNodeBase {\n    constructor(elementRef, tree, renderer, cdr) {\n      super(elementRef, tree);\n      this.elementRef = elementRef;\n      this.tree = tree;\n      this.renderer = renderer;\n      this.cdr = cdr;\n      this.indents = [];\n      this.disabled = false;\n      this.selected = false;\n      this.isLeaf = false;\n\n      this._elementRef.nativeElement.classList.add('ant-tree-treenode');\n    }\n\n    ngOnInit() {\n      this.isLeaf = !this.tree.treeControl.isExpandable(this.data);\n    }\n\n    disable() {\n      this.disabled = true;\n      this.updateDisabledClass();\n    }\n\n    enable() {\n      this.disabled = false;\n      this.updateDisabledClass();\n    }\n\n    select() {\n      this.selected = true;\n      this.updateSelectedClass();\n    }\n\n    deselect() {\n      this.selected = false;\n      this.updateSelectedClass();\n    }\n\n    setIndents(indents) {\n      this.indents = indents;\n      this.cdr.markForCheck();\n    }\n\n    updateSelectedClass() {\n      if (this.selected) {\n        this.renderer.addClass(this.elementRef.nativeElement, 'ant-tree-treenode-selected');\n      } else {\n        this.renderer.removeClass(this.elementRef.nativeElement, 'ant-tree-treenode-selected');\n      }\n    }\n\n    updateDisabledClass() {\n      if (this.disabled) {\n        this.renderer.addClass(this.elementRef.nativeElement, 'ant-tree-treenode-disabled');\n      } else {\n        this.renderer.removeClass(this.elementRef.nativeElement, 'ant-tree-treenode-disabled');\n      }\n    }\n\n  }\n\n  NzTreeNodeComponent.ɵfac = function NzTreeNodeComponent_Factory(t) {\n    return new (t || NzTreeNodeComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NzTreeView), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef));\n  };\n\n  NzTreeNodeComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NzTreeNodeComponent,\n    selectors: [[\"nz-tree-node\", 3, \"builtin\", \"\"]],\n    hostVars: 4,\n    hostBindings: function NzTreeNodeComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"ant-tree-treenode-switcher-open\", ctx.isExpanded)(\"ant-tree-treenode-switcher-close\", !ctx.isExpanded);\n      }\n    },\n    exportAs: [\"nzTreeNode\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: CdkTreeNode,\n      useExisting: NzTreeNodeComponent\n    }, {\n      provide: NzNodeBase,\n      useExisting: NzTreeNodeComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    ngContentSelectors: _c1,\n    decls: 6,\n    vars: 2,\n    consts: [[3, \"indents\", 4, \"ngIf\"], [\"class\", \"nz-tree-leaf-line-icon\", \"nzTreeNodeNoopToggle\", \"\", 4, \"ngIf\"], [3, \"indents\"], [\"nzTreeNodeNoopToggle\", \"\", 1, \"nz-tree-leaf-line-icon\"], [1, \"ant-tree-switcher-leaf-line\"]],\n    template: function NzTreeNodeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c0);\n        i0.ɵɵtemplate(0, NzTreeNodeComponent_nz_tree_node_indents_0_Template, 1, 1, \"nz-tree-node-indents\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵtemplate(2, NzTreeNodeComponent_nz_tree_node_toggle_2_Template, 2, 0, \"nz-tree-node-toggle\", 1);\n        i0.ɵɵprojection(3, 1);\n        i0.ɵɵprojection(4, 2);\n        i0.ɵɵprojection(5, 3);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngIf\", ctx.indents.length);\n        i0.ɵɵadvance(2);\n        i0.ɵɵproperty(\"ngIf\", ctx.indents.length && ctx.isLeaf);\n      }\n    },\n    directives: [NzTreeNodeIndentsComponent, i1$1.NgIf, NzTreeNodeNoopToggleDirective],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return NzTreeNodeComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NzTreeNodeDefDirective = /*#__PURE__*/(() => {\n  class NzTreeNodeDefDirective extends CdkTreeNodeDef {}\n\n  NzTreeNodeDefDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵNzTreeNodeDefDirective_BaseFactory;\n    return function NzTreeNodeDefDirective_Factory(t) {\n      return (ɵNzTreeNodeDefDirective_BaseFactory || (ɵNzTreeNodeDefDirective_BaseFactory = i0.ɵɵgetInheritedFactory(NzTreeNodeDefDirective)))(t || NzTreeNodeDefDirective);\n    };\n  }();\n\n  NzTreeNodeDefDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NzTreeNodeDefDirective,\n    selectors: [[\"\", \"nzTreeNodeDef\", \"\"]],\n    inputs: {\n      when: [\"nzTreeNodeDefWhen\", \"when\"]\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: CdkTreeNodeDef,\n      useExisting: NzTreeNodeDefDirective\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return NzTreeNodeDefDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NzTreeVirtualScrollNodeOutletDirective = /*#__PURE__*/(() => {\n  class NzTreeVirtualScrollNodeOutletDirective {\n    constructor(_viewContainerRef) {\n      this._viewContainerRef = _viewContainerRef;\n      this._viewRef = null;\n    }\n\n    ngOnChanges(changes) {\n      const recreateView = this.shouldRecreateView(changes);\n\n      if (recreateView) {\n        const viewContainerRef = this._viewContainerRef;\n\n        if (this._viewRef) {\n          viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef));\n        }\n\n        this._viewRef = this.data ? viewContainerRef.createEmbeddedView(this.data.nodeDef.template, this.data.context) : null;\n\n        if (CdkTreeNode.mostRecentTreeNode && this._viewRef) {\n          CdkTreeNode.mostRecentTreeNode.data = this.data.data;\n        }\n      } else if (this._viewRef && this.data.context) {\n        this.updateExistingContext(this.data.context);\n      }\n    }\n\n    shouldRecreateView(changes) {\n      const ctxChange = changes.data;\n      return ctxChange && this.hasContextShapeChanged(ctxChange);\n    }\n\n    hasContextShapeChanged(ctxChange) {\n      var _a, _b;\n\n      const prevCtxKeys = Object.keys(ctxChange.previousValue || {});\n      const currCtxKeys = Object.keys(ctxChange.currentValue || {});\n\n      if (prevCtxKeys.length === currCtxKeys.length) {\n        for (const propName of currCtxKeys) {\n          if (prevCtxKeys.indexOf(propName) === -1) {\n            return true;\n          }\n        }\n\n        return ((_a = ctxChange.previousValue) === null || _a === void 0 ? void 0 : _a.data) !== ((_b = ctxChange.currentValue) === null || _b === void 0 ? void 0 : _b.data);\n      }\n\n      return true;\n    }\n\n    updateExistingContext(ctx) {\n      for (const propName of Object.keys(ctx)) {\n        this._viewRef.context[propName] = this.data.context[propName];\n      }\n    }\n\n  }\n\n  NzTreeVirtualScrollNodeOutletDirective.ɵfac = function NzTreeVirtualScrollNodeOutletDirective_Factory(t) {\n    return new (t || NzTreeVirtualScrollNodeOutletDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef));\n  };\n\n  NzTreeVirtualScrollNodeOutletDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NzTreeVirtualScrollNodeOutletDirective,\n    selectors: [[\"\", \"nzTreeVirtualScrollNodeOutlet\", \"\"]],\n    inputs: {\n      data: \"data\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n  return NzTreeVirtualScrollNodeOutletDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NzTreeNodeOptionComponent = /*#__PURE__*/(() => {\n  class NzTreeNodeOptionComponent {\n    constructor(treeNode) {\n      this.treeNode = treeNode;\n      this.nzSelected = false;\n      this.nzDisabled = false;\n      this.nzClick = new EventEmitter();\n    }\n\n    get isExpanded() {\n      return this.treeNode.isExpanded;\n    }\n\n    onClick(e) {\n      if (!this.nzDisabled) {\n        this.nzClick.emit(e);\n      }\n    }\n\n    ngOnChanges(changes) {\n      const {\n        nzDisabled,\n        nzSelected\n      } = changes;\n\n      if (nzDisabled) {\n        if (nzDisabled.currentValue) {\n          this.treeNode.disable();\n        } else {\n          this.treeNode.enable();\n        }\n      }\n\n      if (nzSelected) {\n        if (nzSelected.currentValue) {\n          this.treeNode.select();\n        } else {\n          this.treeNode.deselect();\n        }\n      }\n    }\n\n  }\n\n  NzTreeNodeOptionComponent.ɵfac = function NzTreeNodeOptionComponent_Factory(t) {\n    return new (t || NzTreeNodeOptionComponent)(i0.ɵɵdirectiveInject(NzTreeNodeComponent));\n  };\n\n  NzTreeNodeOptionComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NzTreeNodeOptionComponent,\n    selectors: [[\"nz-tree-node-option\"]],\n    hostAttrs: [1, \"ant-tree-node-content-wrapper\"],\n    hostVars: 4,\n    hostBindings: function NzTreeNodeOptionComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function NzTreeNodeOptionComponent_click_HostBindingHandler($event) {\n          return ctx.onClick($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"ant-tree-node-content-wrapper-open\", ctx.isExpanded)(\"ant-tree-node-selected\", ctx.nzSelected);\n      }\n    },\n    inputs: {\n      nzSelected: \"nzSelected\",\n      nzDisabled: \"nzDisabled\"\n    },\n    outputs: {\n      nzClick: \"nzClick\"\n    },\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c2,\n    decls: 2,\n    vars: 0,\n    consts: [[1, \"ant-tree-title\"]],\n    template: function NzTreeNodeOptionComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"span\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([InputBoolean()], NzTreeNodeOptionComponent.prototype, \"nzSelected\", void 0);\n\n  __decorate([InputBoolean()], NzTreeNodeOptionComponent.prototype, \"nzDisabled\", void 0);\n\n  return NzTreeNodeOptionComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzTreeNodeOutletDirective = /*#__PURE__*/(() => {\n  class NzTreeNodeOutletDirective {\n    constructor(viewContainer, _node) {\n      this.viewContainer = viewContainer;\n      this._node = _node;\n    }\n\n  }\n\n  NzTreeNodeOutletDirective.ɵfac = function NzTreeNodeOutletDirective_Factory(t) {\n    return new (t || NzTreeNodeOutletDirective)(i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(CDK_TREE_NODE_OUTLET_NODE, 8));\n  };\n\n  NzTreeNodeOutletDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NzTreeNodeOutletDirective,\n    selectors: [[\"\", \"nzTreeNodeOutlet\", \"\"]],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: CdkTreeNodeOutlet,\n      useExisting: NzTreeNodeOutletDirective\n    }])]\n  });\n  return NzTreeNodeOutletDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NzTreeNodePaddingDirective = /*#__PURE__*/(() => {\n  class NzTreeNodePaddingDirective extends CdkTreeNodePadding {\n    constructor() {\n      super(...arguments);\n      this._indent = 24;\n    }\n\n    get level() {\n      return this._level;\n    }\n\n    set level(value) {\n      this._setLevelInput(value);\n    }\n\n    get indent() {\n      return this._indent;\n    }\n\n    set indent(indent) {\n      this._setIndentInput(indent);\n    }\n\n  }\n\n  NzTreeNodePaddingDirective.ɵfac = /* @__PURE__ */function () {\n    let ɵNzTreeNodePaddingDirective_BaseFactory;\n    return function NzTreeNodePaddingDirective_Factory(t) {\n      return (ɵNzTreeNodePaddingDirective_BaseFactory || (ɵNzTreeNodePaddingDirective_BaseFactory = i0.ɵɵgetInheritedFactory(NzTreeNodePaddingDirective)))(t || NzTreeNodePaddingDirective);\n    };\n  }();\n\n  NzTreeNodePaddingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NzTreeNodePaddingDirective,\n    selectors: [[\"\", \"nzTreeNodePadding\", \"\"]],\n    inputs: {\n      level: [\"nzTreeNodePadding\", \"level\"],\n      indent: [\"nzTreeNodePaddingIndent\", \"indent\"]\n    },\n    features: [i0.ɵɵProvidersFeature([{\n      provide: CdkTreeNodePadding,\n      useExisting: NzTreeNodePaddingDirective\n    }]), i0.ɵɵInheritDefinitionFeature]\n  });\n  return NzTreeNodePaddingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzTreeViewComponent = /*#__PURE__*/(() => {\n  class NzTreeViewComponent extends NzTreeView {\n    constructor() {\n      super(...arguments);\n      this._afterViewInit = false;\n    }\n\n    ngAfterViewInit() {\n      Promise.resolve().then(() => {\n        this._afterViewInit = true;\n        this.changeDetectorRef.markForCheck();\n      });\n    }\n\n  }\n\n  NzTreeViewComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵNzTreeViewComponent_BaseFactory;\n    return function NzTreeViewComponent_Factory(t) {\n      return (ɵNzTreeViewComponent_BaseFactory || (ɵNzTreeViewComponent_BaseFactory = i0.ɵɵgetInheritedFactory(NzTreeViewComponent)))(t || NzTreeViewComponent);\n    };\n  }();\n\n  NzTreeViewComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NzTreeViewComponent,\n    selectors: [[\"nz-tree-view\"]],\n    viewQuery: function NzTreeViewComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(NzTreeNodeOutletDirective, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodeOutlet = _t.first);\n      }\n    },\n    hostAttrs: [1, \"ant-tree\"],\n    hostVars: 6,\n    hostBindings: function NzTreeViewComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"ant-tree-block-node\", ctx.nzDirectoryTree || ctx.nzBlockNode)(\"ant-tree-directory\", ctx.nzDirectoryTree)(\"ant-tree-rtl\", ctx.dir === \"rtl\");\n      }\n    },\n    exportAs: [\"nzTreeView\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: CdkTree,\n      useExisting: NzTreeViewComponent\n    }, {\n      provide: NzTreeView,\n      useExisting: NzTreeViewComponent\n    }]), i0.ɵɵInheritDefinitionFeature],\n    decls: 3,\n    vars: 2,\n    consts: [[1, \"ant-tree-list-holder\"], [1, \"ant-tree-list-holder-inner\"], [\"nzTreeNodeOutlet\", \"\"]],\n    template: function NzTreeViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelementStart(1, \"div\", 1);\n        i0.ɵɵelementContainer(2, 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"@.disabled\", !ctx._afterViewInit || (ctx.noAnimation == null ? null : ctx.noAnimation.nzNoAnimation))(\"@treeCollapseMotion\", ctx._nodeOutlet.viewContainer.length);\n      }\n    },\n    directives: [NzTreeNodeOutletDirective],\n    encapsulation: 2,\n    data: {\n      animation: [treeCollapseMotion]\n    },\n    changeDetection: 0\n  });\n  return NzTreeViewComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nconst DEFAULT_SIZE = 28;\nlet NzTreeVirtualScrollViewComponent = /*#__PURE__*/(() => {\n  class NzTreeVirtualScrollViewComponent extends NzTreeView {\n    constructor() {\n      super(...arguments);\n      this.nzItemSize = DEFAULT_SIZE;\n      this.nzMinBufferPx = DEFAULT_SIZE * 5;\n      this.nzMaxBufferPx = DEFAULT_SIZE * 10;\n      this.nodes = [];\n\n      this.innerTrackBy = i => i;\n    }\n\n    ngOnChanges(changes) {\n      if (changes.trackBy) {\n        if (typeof changes.trackBy.currentValue === 'function') {\n          this.innerTrackBy = (index, n) => this.trackBy(index, n.data);\n        } else {\n          this.innerTrackBy = i => i;\n        }\n      }\n    }\n\n    renderNodeChanges(data) {\n      this.nodes = new Array(...data).map((n, i) => this.createNode(n, i));\n\n      this._dataSourceChanged.next();\n    }\n\n    createNode(nodeData, index) {\n      const node = this._getNodeDef(nodeData, index);\n\n      const context = new CdkTreeNodeOutletContext(nodeData);\n\n      if (this.treeControl.getLevel) {\n        context.level = this.treeControl.getLevel(nodeData);\n      } else {\n        context.level = 0;\n      }\n\n      return {\n        data: nodeData,\n        context,\n        nodeDef: node\n      };\n    }\n\n  }\n\n  NzTreeVirtualScrollViewComponent.ɵfac = /* @__PURE__ */function () {\n    let ɵNzTreeVirtualScrollViewComponent_BaseFactory;\n    return function NzTreeVirtualScrollViewComponent_Factory(t) {\n      return (ɵNzTreeVirtualScrollViewComponent_BaseFactory || (ɵNzTreeVirtualScrollViewComponent_BaseFactory = i0.ɵɵgetInheritedFactory(NzTreeVirtualScrollViewComponent)))(t || NzTreeVirtualScrollViewComponent);\n    };\n  }();\n\n  NzTreeVirtualScrollViewComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NzTreeVirtualScrollViewComponent,\n    selectors: [[\"nz-tree-virtual-scroll-view\"]],\n    viewQuery: function NzTreeVirtualScrollViewComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(NzTreeNodeOutletDirective, 7);\n        i0.ɵɵviewQuery(CdkVirtualScrollViewport, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.nodeOutlet = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.virtualScrollViewport = _t.first);\n      }\n    },\n    hostAttrs: [1, \"ant-tree\"],\n    hostVars: 6,\n    hostBindings: function NzTreeVirtualScrollViewComponent_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"ant-tree-block-node\", ctx.nzDirectoryTree || ctx.nzBlockNode)(\"ant-tree-directory\", ctx.nzDirectoryTree)(\"ant-tree-rtl\", ctx.dir === \"rtl\");\n      }\n    },\n    inputs: {\n      nzItemSize: \"nzItemSize\",\n      nzMinBufferPx: \"nzMinBufferPx\",\n      nzMaxBufferPx: \"nzMaxBufferPx\",\n      trackBy: \"trackBy\"\n    },\n    exportAs: [\"nzTreeVirtualScrollView\"],\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NzTreeView,\n      useExisting: NzTreeVirtualScrollViewComponent\n    }, {\n      provide: CdkTree,\n      useExisting: NzTreeVirtualScrollViewComponent\n    }]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵNgOnChangesFeature],\n    decls: 4,\n    vars: 5,\n    consts: [[1, \"ant-tree-list\"], [1, \"ant-tree-list-holder\", 3, \"itemSize\", \"minBufferPx\", \"maxBufferPx\"], [4, \"cdkVirtualFor\", \"cdkVirtualForOf\", \"cdkVirtualForTrackBy\"], [\"nzTreeNodeOutlet\", \"\"], [\"nzTreeVirtualScrollNodeOutlet\", \"\", 3, \"data\"]],\n    template: function NzTreeVirtualScrollViewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelementStart(1, \"cdk-virtual-scroll-viewport\", 1);\n        i0.ɵɵtemplate(2, NzTreeVirtualScrollViewComponent_ng_container_2_Template, 2, 1, \"ng-container\", 2);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementContainer(3, 3);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"itemSize\", ctx.nzItemSize)(\"minBufferPx\", ctx.nzMinBufferPx)(\"maxBufferPx\", ctx.nzMaxBufferPx);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"cdkVirtualForOf\", ctx.nodes)(\"cdkVirtualForTrackBy\", ctx.innerTrackBy);\n      }\n    },\n    directives: [i1$2.CdkVirtualScrollViewport, i1$2.CdkFixedSizeVirtualScroll, i1$2.CdkVirtualForOf, NzTreeVirtualScrollNodeOutletDirective, NzTreeNodeOutletDirective],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return NzTreeVirtualScrollViewComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nconst treeWithControlComponents = [NzTreeView, NzTreeNodeOutletDirective, NzTreeViewComponent, NzTreeNodeDefDirective, NzTreeNodeComponent, NzTreeNodeToggleDirective, NzTreeNodePaddingDirective, NzTreeNodeToggleRotateIconDirective, NzTreeNodeToggleActiveIconDirective, NzTreeNodeOptionComponent, NzTreeNodeNoopToggleDirective, NzTreeNodeCheckboxComponent, NzTreeNodeIndentsComponent, NzTreeVirtualScrollViewComponent, NzTreeVirtualScrollNodeOutletDirective, NzTreeNodeIndentLineDirective];\nlet NzTreeViewModule = /*#__PURE__*/(() => {\n  class NzTreeViewModule {}\n\n  NzTreeViewModule.ɵfac = function NzTreeViewModule_Factory(t) {\n    return new (t || NzTreeViewModule)();\n  };\n\n  NzTreeViewModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NzTreeViewModule\n  });\n  NzTreeViewModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[BidiModule, CommonModule, NzNoAnimationModule, ScrollingModule]]\n  });\n  return NzTreeViewModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nclass NzTreeFlattener {\n  constructor(transformFunction, getLevel, isExpandable, getChildren) {\n    this.transformFunction = transformFunction;\n    this.getLevel = getLevel;\n    this.isExpandable = isExpandable;\n    this.getChildren = getChildren;\n  }\n\n  flattenNode(node, level, resultNodes, parentMap) {\n    const flatNode = this.transformFunction(node, level);\n    resultNodes.push(flatNode);\n\n    if (this.isExpandable(flatNode)) {\n      const childrenNodes = this.getChildren(node);\n\n      if (childrenNodes) {\n        if (Array.isArray(childrenNodes)) {\n          this.flattenChildren(childrenNodes, level, resultNodes, parentMap);\n        } else {\n          childrenNodes.pipe(take(1)).subscribe(children => {\n            this.flattenChildren(children, level, resultNodes, parentMap);\n          });\n        }\n      }\n    }\n\n    return resultNodes;\n  }\n\n  flattenChildren(children, level, resultNodes, parentMap) {\n    children.forEach((child, index) => {\n      const childParentMap = parentMap.slice();\n      childParentMap.push(index !== children.length - 1);\n      this.flattenNode(child, level + 1, resultNodes, childParentMap);\n    });\n  }\n  /**\n   * Flatten a list of node type T to flattened version of node F.\n   * Please note that type T may be nested, and the length of `structuredData` may be different\n   * from that of returned list `F[]`.\n   */\n\n\n  flattenNodes(structuredData) {\n    const resultNodes = [];\n    structuredData.forEach(node => this.flattenNode(node, 0, resultNodes, []));\n    return resultNodes;\n  }\n  /**\n   * Expand flattened node with current expansion status.\n   * The returned list may have different length.\n   */\n\n\n  expandFlattenedNodes(nodes, treeControl) {\n    const results = [];\n    const currentExpand = [];\n    currentExpand[0] = true;\n    nodes.forEach(node => {\n      let expand = true;\n\n      for (let i = 0; i <= this.getLevel(node); i++) {\n        expand = expand && currentExpand[i];\n      }\n\n      if (expand) {\n        results.push(node);\n      }\n\n      if (this.isExpandable(node)) {\n        currentExpand[this.getLevel(node) + 1] = treeControl.isExpanded(node);\n      }\n    });\n    return results;\n  }\n\n}\n\nclass NzTreeFlatDataSource extends DataSource {\n  constructor(_treeControl, _treeFlattener, initialData = []) {\n    super();\n    this._treeControl = _treeControl;\n    this._treeFlattener = _treeFlattener;\n    this._flattenedData = new BehaviorSubject([]);\n    this._expandedData = new BehaviorSubject([]);\n    this._data = new BehaviorSubject(initialData);\n    this.flatNodes();\n  }\n\n  setData(value) {\n    this._data.next(value);\n\n    this.flatNodes();\n  }\n\n  getData() {\n    return this._data.getValue();\n  }\n\n  connect(collectionViewer) {\n    const changes = [collectionViewer.viewChange, this._treeControl.expansionModel.changed, this._flattenedData];\n    return merge(...changes).pipe(map(() => {\n      this._expandedData.next(this._treeFlattener.expandFlattenedNodes(this._flattenedData.value, this._treeControl));\n\n      return this._expandedData.value;\n    }));\n  }\n\n  disconnect() {// no op\n  }\n\n  flatNodes() {\n    this._flattenedData.next(this._treeFlattener.flattenNodes(this.getData()));\n\n    this._treeControl.dataNodes = this._flattenedData.value;\n  }\n\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzTreeFlatDataSource, NzTreeFlattener, NzTreeNodeCheckboxComponent, NzTreeNodeComponent, NzTreeNodeDefDirective, NzTreeNodeIndentLineDirective, NzTreeNodeIndentsComponent, NzTreeNodeNoopToggleDirective, NzTreeNodeOptionComponent, NzTreeNodeOutletDirective, NzTreeNodePaddingDirective, NzTreeNodeToggleActiveIconDirective, NzTreeNodeToggleDirective, NzTreeNodeToggleRotateIconDirective, NzTreeView, NzTreeViewComponent, NzTreeViewModule, NzTreeVirtualScrollNodeOutletDirective, NzTreeVirtualScrollViewComponent, getNextSibling, getParent }; //# sourceMappingURL=ng-zorro-antd-tree-view.mjs.map","map":null,"metadata":{},"sourceType":"module"}