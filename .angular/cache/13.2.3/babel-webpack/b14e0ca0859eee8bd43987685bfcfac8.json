{"ast":null,"code":"import { __decorate } from 'tslib';\nimport * as i4 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, ViewChild, Injector, Injectable, Optional, Directive, Inject, Input, NgModule } from '@angular/core';\nimport { Subject, fromEvent } from 'rxjs';\nimport { filter, take, takeUntil } from 'rxjs/operators';\nimport * as i1 from 'ng-zorro-antd/core/config';\nimport { WithConfig } from 'ng-zorro-antd/core/config';\nimport { isNotNil, InputBoolean } from 'ng-zorro-antd/core/util';\nimport * as i3 from '@angular/cdk/overlay';\nimport { OverlayRef, OverlayConfig, OverlayModule } from '@angular/cdk/overlay';\nimport { ComponentPortal, PortalModule } from '@angular/cdk/portal';\nimport { ESCAPE, hasModifierKey } from '@angular/cdk/keycodes';\nimport { fadeMotion } from 'ng-zorro-antd/core/animation';\nimport * as i5 from 'ng-zorro-antd/icon';\nimport { NzIconModule } from 'ng-zorro-antd/icon';\nimport * as i6 from '@angular/cdk/drag-drop';\nimport { DragDropModule } from '@angular/cdk/drag-drop';\nimport * as i3$1 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport { NzPipesModule } from 'ng-zorro-antd/pipes';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nconst _c0 = [\"imgRef\"];\n\nfunction NzImagePreviewComponent_li_5_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r5 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"li\", 9);\n    i0.ɵɵlistener(\"click\", function NzImagePreviewComponent_li_5_Template_li_click_0_listener() {\n      const restoredCtx = i0.ɵɵrestoreView(_r5);\n      const option_r3 = restoredCtx.$implicit;\n      return option_r3.onClick();\n    });\n    i0.ɵɵelement(1, \"span\", 10);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const option_r3 = ctx.$implicit;\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"ant-image-preview-operations-operation-disabled\", ctx_r0.zoomOutDisabled && option_r3.type === \"zoomOut\");\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"nzType\", option_r3.icon);\n  }\n}\n\nfunction NzImagePreviewComponent_ng_container_7_img_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"img\", 12, 13);\n  }\n\n  if (rf & 2) {\n    const image_r6 = i0.ɵɵnextContext().$implicit;\n    const ctx_r8 = i0.ɵɵnextContext();\n    i0.ɵɵstyleProp(\"width\", image_r6.width)(\"height\", image_r6.height)(\"transform\", ctx_r8.previewImageTransform);\n    i0.ɵɵattribute(\"src\", image_r6.src, i0.ɵɵsanitizeUrl)(\"srcset\", image_r6.srcset, i0.ɵɵsanitizeUrl)(\"alt\", image_r6.alt);\n  }\n}\n\nfunction NzImagePreviewComponent_ng_container_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtemplate(1, NzImagePreviewComponent_ng_container_7_img_1_Template, 2, 9, \"img\", 11);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const imageIndex_r7 = ctx.index;\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵproperty(\"ngIf\", ctx_r1.index === imageIndex_r7);\n  }\n}\n\nfunction NzImagePreviewComponent_ng_container_8_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r12 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵelementStart(1, \"div\", 14);\n    i0.ɵɵlistener(\"click\", function NzImagePreviewComponent_ng_container_8_Template_div_click_1_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r11 = i0.ɵɵnextContext();\n      return ctx_r11.onSwitchLeft($event);\n    });\n    i0.ɵɵelement(2, \"span\", 15);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"div\", 16);\n    i0.ɵɵlistener(\"click\", function NzImagePreviewComponent_ng_container_8_Template_div_click_3_listener($event) {\n      i0.ɵɵrestoreView(_r12);\n      const ctx_r13 = i0.ɵɵnextContext();\n      return ctx_r13.onSwitchRight($event);\n    });\n    i0.ɵɵelement(4, \"span\", 17);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵclassProp(\"ant-image-preview-switch-left-disabled\", ctx_r2.index <= 0);\n    i0.ɵɵadvance(2);\n    i0.ɵɵclassProp(\"ant-image-preview-switch-right-disabled\", ctx_r2.index >= ctx_r2.images.length - 1);\n  }\n}\n\nconst _c1 = [\"*\"];\nconst FADE_CLASS_NAME_MAP = {\n  enter: 'ant-fade-enter',\n  enterActive: 'ant-fade-enter-active',\n  leave: 'ant-fade-leave',\n  leaveActive: 'ant-fade-leave-active'\n};\nconst IMAGE_PREVIEW_MASK_CLASS_NAME = 'ant-image-preview-mask';\nconst NZ_CONFIG_MODULE_NAME$1 = 'image';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nclass NzImagePreviewOptions {\n  constructor() {\n    this.nzKeyboard = true;\n    this.nzNoAnimation = false;\n    this.nzMaskClosable = true;\n    this.nzCloseOnNavigation = true;\n  }\n\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nclass NzImagePreviewRef {\n  constructor(previewInstance, config, overlayRef) {\n    this.previewInstance = previewInstance;\n    this.config = config;\n    this.overlayRef = overlayRef;\n    this.destroy$ = new Subject();\n    overlayRef.keydownEvents().pipe(filter(event => this.config.nzKeyboard && event.keyCode === ESCAPE && !hasModifierKey(event))).subscribe(event => {\n      event.preventDefault();\n      this.close();\n    });\n    overlayRef.detachments().subscribe(() => {\n      this.overlayRef.dispose();\n    });\n    previewInstance.containerClick.pipe(take(1), takeUntil(this.destroy$)).subscribe(() => {\n      this.close();\n    });\n    previewInstance.closeClick.pipe(take(1), takeUntil(this.destroy$)).subscribe(() => {\n      this.close();\n    });\n    previewInstance.animationStateChanged.pipe(filter(event => event.phaseName === 'done' && event.toState === 'leave'), take(1)).subscribe(() => {\n      this.dispose();\n    });\n  }\n\n  switchTo(index) {\n    this.previewInstance.switchTo(index);\n  }\n\n  next() {\n    this.previewInstance.next();\n  }\n\n  prev() {\n    this.previewInstance.prev();\n  }\n\n  close() {\n    this.previewInstance.startLeaveAnimation();\n  }\n\n  dispose() {\n    this.destroy$.next();\n    this.overlayRef.dispose();\n  }\n\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * fit content details: https://github.com/NG-ZORRO/ng-zorro-antd/pull/6154#issuecomment-745025554\n *\n * calc position x,y point\n *\n * CASE (width <= clientWidth && height <= clientHeight):\n *\n * ------------- clientWidth -------------\n * |                                     |\n * |        ------ width ------          |\n * |        |                 |          |\n * |        |                 |          |\n * client   height            |          |\n * Height   |                 |          |\n * |        |                 |          |\n * |        -------------------          |\n * |                                     |\n * |                                     |\n * ---------------------------------------\n * fixedPosition = { x: 0, y: 0 }\n *\n *\n *\n * CASE (width > clientWidth || height > clientHeight):\n *\n * ------------- clientWidth -------------\n * |        |                            |\n * |        top                          |\n * |        |                            |\n * |--left--|--------------- width -----------------\n * |        |                                      |\n * client   |                                      |\n * Height   |                                      |\n * |        |                                      |\n * |        |                                      |\n * |        height                                 |\n * |        |                                      |\n * ---------|                                      |\n *          |                                      |\n *          |                                      |\n *          |                                      |\n *          ----------------------------------------\n *\n *\n * - left || top > 0\n *   left -> 0 || top -> 0\n *\n * - (left + width) < clientWidth || (top + height) < clientHeight\n * - left | top + width | height < clientWidth | clientHeight -> Back left | top + width | height === clientWidth | clientHeight\n *\n * DEFAULT:\n * - hold position\n *\n */\n\n\nfunction getFitContentPosition(params) {\n  let fixPos = {};\n\n  if (params.width <= params.clientWidth && params.height <= params.clientHeight) {\n    fixPos = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  if (params.width > params.clientWidth || params.height > params.clientHeight) {\n    fixPos = {\n      x: fitPoint(params.left, params.width, params.clientWidth),\n      y: fitPoint(params.top, params.height, params.clientHeight)\n    };\n  }\n\n  return fixPos;\n}\n\nfunction getOffset(node) {\n  const box = node.getBoundingClientRect();\n  const docElem = document.documentElement; // use docElem.scrollLeft to support IE\n\n  return {\n    left: box.left + (window.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || document.body.clientLeft || 0),\n    top: box.top + (window.pageYOffset || docElem.scrollTop) - (docElem.clientTop || document.body.clientTop || 0)\n  };\n}\n\nfunction getClientSize() {\n  const width = document.documentElement.clientWidth;\n  const height = window.innerHeight || document.documentElement.clientHeight;\n  return {\n    width,\n    height\n  };\n}\n\nfunction fitPoint(start, size, clientSize) {\n  const startAddSize = start + size;\n  const offsetStart = (size - clientSize) / 2;\n  let distance = null;\n\n  if (size > clientSize) {\n    if (start > 0) {\n      distance = offsetStart;\n    }\n\n    if (start < 0 && startAddSize < clientSize) {\n      distance = -offsetStart;\n    }\n  } else {\n    if (start < 0 || startAddSize > clientSize) {\n      distance = start < 0 ? offsetStart : -offsetStart;\n    }\n  }\n\n  return distance;\n}\n\nconst initialPosition = {\n  x: 0,\n  y: 0\n};\nlet NzImagePreviewComponent = /*#__PURE__*/(() => {\n  class NzImagePreviewComponent {\n    constructor(cdr, nzConfigService, config, overlayRef) {\n      var _a, _b;\n\n      this.cdr = cdr;\n      this.nzConfigService = nzConfigService;\n      this.config = config;\n      this.overlayRef = overlayRef;\n      this.images = [];\n      this.index = 0;\n      this.isDragging = false;\n      this.visible = true;\n      this.animationState = 'enter';\n      this.animationStateChanged = new EventEmitter();\n      this.previewImageTransform = '';\n      this.previewImageWrapperTransform = '';\n      this.operations = [{\n        icon: 'close',\n        onClick: () => {\n          this.onClose();\n        },\n        type: 'close'\n      }, {\n        icon: 'zoom-in',\n        onClick: () => {\n          this.onZoomIn();\n        },\n        type: 'zoomIn'\n      }, {\n        icon: 'zoom-out',\n        onClick: () => {\n          this.onZoomOut();\n        },\n        type: 'zoomOut'\n      }, {\n        icon: 'rotate-right',\n        onClick: () => {\n          this.onRotateRight();\n        },\n        type: 'rotateRight'\n      }, {\n        icon: 'rotate-left',\n        onClick: () => {\n          this.onRotateLeft();\n        },\n        type: 'rotateLeft'\n      }];\n      this.zoomOutDisabled = false;\n      this.position = Object.assign({}, initialPosition);\n      this.containerClick = new EventEmitter();\n      this.closeClick = new EventEmitter();\n      this.destroy$ = new Subject();\n      this.zoom = (_a = this.config.nzZoom) !== null && _a !== void 0 ? _a : 1;\n      this.rotate = (_b = this.config.nzRotate) !== null && _b !== void 0 ? _b : 0;\n      this.updateZoomOutDisabled();\n      this.updatePreviewImageTransform();\n      this.updatePreviewImageWrapperTransform();\n    }\n\n    get animationDisabled() {\n      var _a;\n\n      return (_a = this.config.nzNoAnimation) !== null && _a !== void 0 ? _a : false;\n    }\n\n    get maskClosable() {\n      var _a, _b;\n\n      const defaultConfig = this.nzConfigService.getConfigForComponent(NZ_CONFIG_MODULE_NAME$1) || {};\n      return (_b = (_a = this.config.nzMaskClosable) !== null && _a !== void 0 ? _a : defaultConfig.nzMaskClosable) !== null && _b !== void 0 ? _b : true;\n    }\n\n    setImages(images) {\n      this.images = images;\n      this.cdr.markForCheck();\n    }\n\n    switchTo(index) {\n      this.index = index;\n      this.cdr.markForCheck();\n    }\n\n    next() {\n      if (this.index < this.images.length - 1) {\n        this.reset();\n        this.index++;\n        this.updatePreviewImageTransform();\n        this.updatePreviewImageWrapperTransform();\n        this.updateZoomOutDisabled();\n        this.cdr.markForCheck();\n      }\n    }\n\n    prev() {\n      if (this.index > 0) {\n        this.reset();\n        this.index--;\n        this.updatePreviewImageTransform();\n        this.updatePreviewImageWrapperTransform();\n        this.updateZoomOutDisabled();\n        this.cdr.markForCheck();\n      }\n    }\n\n    markForCheck() {\n      this.cdr.markForCheck();\n    }\n\n    onClose() {\n      this.closeClick.emit();\n    }\n\n    onZoomIn() {\n      this.zoom += 1;\n      this.updatePreviewImageTransform();\n      this.updateZoomOutDisabled();\n      this.position = Object.assign({}, initialPosition);\n    }\n\n    onZoomOut() {\n      if (this.zoom > 1) {\n        this.zoom -= 1;\n        this.updatePreviewImageTransform();\n        this.updateZoomOutDisabled();\n        this.position = Object.assign({}, initialPosition);\n      }\n    }\n\n    onRotateRight() {\n      this.rotate += 90;\n      this.updatePreviewImageTransform();\n    }\n\n    onRotateLeft() {\n      this.rotate -= 90;\n      this.updatePreviewImageTransform();\n    }\n\n    onSwitchLeft(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.prev();\n    }\n\n    onSwitchRight(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.next();\n    }\n\n    onContainerClick(e) {\n      if (e.target === e.currentTarget && this.maskClosable) {\n        this.containerClick.emit();\n      }\n    }\n\n    onAnimationStart(event) {\n      if (event.toState === 'enter') {\n        this.setEnterAnimationClass();\n      } else if (event.toState === 'leave') {\n        this.setLeaveAnimationClass();\n      }\n\n      this.animationStateChanged.emit(event);\n    }\n\n    onAnimationDone(event) {\n      if (event.toState === 'enter') {\n        this.setEnterAnimationClass();\n      } else if (event.toState === 'leave') {\n        this.setLeaveAnimationClass();\n      }\n\n      this.animationStateChanged.emit(event);\n    }\n\n    startLeaveAnimation() {\n      this.animationState = 'leave';\n      this.cdr.markForCheck();\n    }\n\n    onDragStarted() {\n      this.isDragging = true;\n    }\n\n    onDragReleased() {\n      this.isDragging = false;\n      const width = this.imageRef.nativeElement.offsetWidth * this.zoom;\n      const height = this.imageRef.nativeElement.offsetHeight * this.zoom;\n      const {\n        left,\n        top\n      } = getOffset(this.imageRef.nativeElement);\n      const {\n        width: clientWidth,\n        height: clientHeight\n      } = getClientSize();\n      const isRotate = this.rotate % 180 !== 0;\n      const fitContentParams = {\n        width: isRotate ? height : width,\n        height: isRotate ? width : height,\n        left,\n        top,\n        clientWidth,\n        clientHeight\n      };\n      const fitContentPos = getFitContentPosition(fitContentParams);\n\n      if (isNotNil(fitContentPos.x) || isNotNil(fitContentPos.y)) {\n        this.position = Object.assign(Object.assign({}, this.position), fitContentPos);\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n    updatePreviewImageTransform() {\n      this.previewImageTransform = `scale3d(${this.zoom}, ${this.zoom}, 1) rotate(${this.rotate}deg)`;\n    }\n\n    updatePreviewImageWrapperTransform() {\n      this.previewImageWrapperTransform = `translate3d(${this.position.x}px, ${this.position.y}px, 0)`;\n    }\n\n    updateZoomOutDisabled() {\n      this.zoomOutDisabled = this.zoom <= 1;\n    }\n\n    setEnterAnimationClass() {\n      if (this.animationDisabled) {\n        return;\n      }\n\n      const backdropElement = this.overlayRef.backdropElement;\n\n      if (backdropElement) {\n        backdropElement.classList.add(FADE_CLASS_NAME_MAP.enter);\n        backdropElement.classList.add(FADE_CLASS_NAME_MAP.enterActive);\n      }\n    }\n\n    setLeaveAnimationClass() {\n      if (this.animationDisabled) {\n        return;\n      }\n\n      const backdropElement = this.overlayRef.backdropElement;\n\n      if (backdropElement) {\n        backdropElement.classList.add(FADE_CLASS_NAME_MAP.leave);\n        backdropElement.classList.add(FADE_CLASS_NAME_MAP.leaveActive);\n      }\n    }\n\n    reset() {\n      this.zoom = 1;\n      this.rotate = 0;\n      this.position = Object.assign({}, initialPosition);\n    }\n\n  }\n\n  NzImagePreviewComponent.ɵfac = function NzImagePreviewComponent_Factory(t) {\n    return new (t || NzImagePreviewComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i1.NzConfigService), i0.ɵɵdirectiveInject(NzImagePreviewOptions), i0.ɵɵdirectiveInject(i3.OverlayRef));\n  };\n\n  NzImagePreviewComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NzImagePreviewComponent,\n    selectors: [[\"nz-image-preview\"]],\n    viewQuery: function NzImagePreviewComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.imageRef = _t.first);\n      }\n    },\n    hostAttrs: [\"tabindex\", \"-1\", \"role\", \"document\", 1, \"ant-image-preview-wrap\"],\n    hostVars: 6,\n    hostBindings: function NzImagePreviewComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵsyntheticHostListener(\"@fadeMotion.start\", function NzImagePreviewComponent_animation_fadeMotion_start_HostBindingHandler($event) {\n          return ctx.onAnimationStart($event);\n        })(\"@fadeMotion.done\", function NzImagePreviewComponent_animation_fadeMotion_done_HostBindingHandler($event) {\n          return ctx.onAnimationDone($event);\n        });\n        i0.ɵɵlistener(\"click\", function NzImagePreviewComponent_click_HostBindingHandler($event) {\n          return ctx.onContainerClick($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵsyntheticHostProperty(\"@.disabled\", ctx.config.nzNoAnimation)(\"@fadeMotion\", ctx.animationState);\n        i0.ɵɵstyleProp(\"z-index\", ctx.config.nzZIndex);\n        i0.ɵɵclassProp(\"ant-image-preview-moving\", ctx.isDragging);\n      }\n    },\n    exportAs: [\"nzImagePreview\"],\n    decls: 10,\n    vars: 6,\n    consts: [[1, \"ant-image-preview\"], [\"tabindex\", \"0\", \"aria-hidden\", \"true\", 2, \"width\", \"0\", \"height\", \"0\", \"overflow\", \"hidden\", \"outline\", \"none\"], [1, \"ant-image-preview-content\"], [1, \"ant-image-preview-body\"], [1, \"ant-image-preview-operations\"], [\"class\", \"ant-image-preview-operations-operation\", 3, \"ant-image-preview-operations-operation-disabled\", \"click\", 4, \"ngFor\", \"ngForOf\"], [\"cdkDrag\", \"\", 1, \"ant-image-preview-img-wrapper\", 3, \"cdkDragFreeDragPosition\", \"mousedown\", \"cdkDragReleased\"], [4, \"ngFor\", \"ngForOf\"], [4, \"ngIf\"], [1, \"ant-image-preview-operations-operation\", 3, \"click\"], [\"nz-icon\", \"\", \"nzTheme\", \"outline\", 1, \"ant-image-preview-operations-icon\", 3, \"nzType\"], [\"cdkDragHandle\", \"\", \"class\", \"ant-image-preview-img\", 3, \"width\", \"height\", \"transform\", 4, \"ngIf\"], [\"cdkDragHandle\", \"\", 1, \"ant-image-preview-img\"], [\"imgRef\", \"\"], [1, \"ant-image-preview-switch-left\", 3, \"click\"], [\"nz-icon\", \"\", \"nzType\", \"left\", \"nzTheme\", \"outline\"], [1, \"ant-image-preview-switch-right\", 3, \"click\"], [\"nz-icon\", \"\", \"nzType\", \"right\", \"nzTheme\", \"outline\"]],\n    template: function NzImagePreviewComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵelement(1, \"div\", 1);\n        i0.ɵɵelementStart(2, \"div\", 2);\n        i0.ɵɵelementStart(3, \"div\", 3);\n        i0.ɵɵelementStart(4, \"ul\", 4);\n        i0.ɵɵtemplate(5, NzImagePreviewComponent_li_5_Template, 2, 3, \"li\", 5);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementStart(6, \"div\", 6);\n        i0.ɵɵlistener(\"mousedown\", function NzImagePreviewComponent_Template_div_mousedown_6_listener() {\n          return ctx.onDragStarted();\n        })(\"cdkDragReleased\", function NzImagePreviewComponent_Template_div_cdkDragReleased_6_listener() {\n          return ctx.onDragReleased();\n        });\n        i0.ɵɵtemplate(7, NzImagePreviewComponent_ng_container_7_Template, 2, 1, \"ng-container\", 7);\n        i0.ɵɵelementEnd();\n        i0.ɵɵtemplate(8, NzImagePreviewComponent_ng_container_8_Template, 5, 4, \"ng-container\", 8);\n        i0.ɵɵelementEnd();\n        i0.ɵɵelementEnd();\n        i0.ɵɵelement(9, \"div\", 1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(5);\n        i0.ɵɵproperty(\"ngForOf\", ctx.operations);\n        i0.ɵɵadvance(1);\n        i0.ɵɵstyleProp(\"transform\", ctx.previewImageWrapperTransform);\n        i0.ɵɵproperty(\"cdkDragFreeDragPosition\", ctx.position);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngForOf\", ctx.images);\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"ngIf\", ctx.images.length > 1);\n      }\n    },\n    directives: [i4.NgForOf, i5.NzIconDirective, i6.CdkDrag, i4.NgIf, i6.CdkDragHandle],\n    encapsulation: 2,\n    data: {\n      animation: [fadeMotion]\n    },\n    changeDetection: 0\n  });\n  return NzImagePreviewComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NzImageService = /*#__PURE__*/(() => {\n  class NzImageService {\n    constructor(overlay, injector, nzConfigService, directionality) {\n      this.overlay = overlay;\n      this.injector = injector;\n      this.nzConfigService = nzConfigService;\n      this.directionality = directionality;\n    }\n\n    preview(images, options) {\n      return this.display(images, options);\n    }\n\n    display(images, config) {\n      const configMerged = Object.assign(Object.assign({}, new NzImagePreviewOptions()), config !== null && config !== void 0 ? config : {});\n      const overlayRef = this.createOverlay(configMerged);\n      const previewComponent = this.attachPreviewComponent(overlayRef, configMerged);\n      previewComponent.setImages(images);\n      const previewRef = new NzImagePreviewRef(previewComponent, configMerged, overlayRef);\n      previewComponent.previewRef = previewRef;\n      return previewRef;\n    }\n\n    attachPreviewComponent(overlayRef, config) {\n      const injector = Injector.create({\n        parent: this.injector,\n        providers: [{\n          provide: OverlayRef,\n          useValue: overlayRef\n        }, {\n          provide: NzImagePreviewOptions,\n          useValue: config\n        }]\n      });\n      const containerPortal = new ComponentPortal(NzImagePreviewComponent, null, injector);\n      const containerRef = overlayRef.attach(containerPortal);\n      return containerRef.instance;\n    }\n\n    createOverlay(config) {\n      var _a, _b;\n\n      const globalConfig = this.nzConfigService.getConfigForComponent(NZ_CONFIG_MODULE_NAME$1) || {};\n      const overLayConfig = new OverlayConfig({\n        hasBackdrop: true,\n        scrollStrategy: this.overlay.scrollStrategies.block(),\n        positionStrategy: this.overlay.position().global(),\n        disposeOnNavigation: (_b = (_a = config.nzCloseOnNavigation) !== null && _a !== void 0 ? _a : globalConfig.nzCloseOnNavigation) !== null && _b !== void 0 ? _b : true,\n        backdropClass: IMAGE_PREVIEW_MASK_CLASS_NAME,\n        direction: config.nzDirection || globalConfig.nzDirection || this.directionality.value\n      });\n      return this.overlay.create(overLayConfig);\n    }\n\n  }\n\n  NzImageService.ɵfac = function NzImageService_Factory(t) {\n    return new (t || NzImageService)(i0.ɵɵinject(i3.Overlay), i0.ɵɵinject(i0.Injector), i0.ɵɵinject(i1.NzConfigService), i0.ɵɵinject(i3$1.Directionality, 8));\n  };\n\n  NzImageService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NzImageService,\n    factory: NzImageService.ɵfac\n  });\n  return NzImageService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzImageGroupComponent = /*#__PURE__*/(() => {\n  class NzImageGroupComponent {\n    constructor() {\n      this.images = [];\n    }\n\n    addImage(image) {\n      this.images.push(image);\n    }\n\n  }\n\n  NzImageGroupComponent.ɵfac = function NzImageGroupComponent_Factory(t) {\n    return new (t || NzImageGroupComponent)();\n  };\n\n  NzImageGroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NzImageGroupComponent,\n    selectors: [[\"nz-image-group\"]],\n    exportAs: [\"nzImageGroup\"],\n    ngContentSelectors: _c1,\n    decls: 1,\n    vars: 0,\n    template: function NzImageGroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return NzImageGroupComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nconst NZ_CONFIG_MODULE_NAME = 'image';\nlet NzImageDirective = /*#__PURE__*/(() => {\n  class NzImageDirective {\n    constructor(document, nzConfigService, elementRef, nzImageService, cdr, parentGroup, directionality) {\n      this.document = document;\n      this.nzConfigService = nzConfigService;\n      this.elementRef = elementRef;\n      this.nzImageService = nzImageService;\n      this.cdr = cdr;\n      this.parentGroup = parentGroup;\n      this.directionality = directionality;\n      this._nzModuleName = NZ_CONFIG_MODULE_NAME;\n      this.nzSrc = '';\n      this.nzSrcset = '';\n      this.nzDisablePreview = false;\n      this.nzFallback = null;\n      this.nzPlaceholder = null;\n      this.status = 'normal';\n      this.backLoadDestroy$ = new Subject();\n      this.destroy$ = new Subject();\n    }\n\n    get previewable() {\n      return !this.nzDisablePreview && this.status !== 'error';\n    }\n\n    ngOnInit() {\n      var _a;\n\n      this.backLoad();\n\n      if (this.parentGroup) {\n        this.parentGroup.addImage(this);\n      }\n\n      if (this.directionality) {\n        (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n          this.dir = direction;\n          this.cdr.detectChanges();\n        });\n        this.dir = this.directionality.value;\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n    onPreview() {\n      if (!this.previewable) {\n        return;\n      }\n\n      if (this.parentGroup) {\n        // preview inside image group\n        const previewAbleImages = this.parentGroup.images.filter(e => e.previewable);\n        const previewImages = previewAbleImages.map(e => ({\n          src: e.nzSrc,\n          srcset: e.nzSrcset\n        }));\n        const previewIndex = previewAbleImages.findIndex(el => this === el);\n        const previewRef = this.nzImageService.preview(previewImages, {\n          nzDirection: this.dir\n        });\n        previewRef.switchTo(previewIndex);\n      } else {\n        // preview not inside image group\n        const previewImages = [{\n          src: this.nzSrc,\n          srcset: this.nzSrcset\n        }];\n        this.nzImageService.preview(previewImages, {\n          nzDirection: this.dir\n        });\n      }\n    }\n\n    getElement() {\n      return this.elementRef;\n    }\n\n    ngOnChanges(changes) {\n      const {\n        nzSrc\n      } = changes;\n\n      if (nzSrc) {\n        this.getElement().nativeElement.src = nzSrc.currentValue;\n        this.backLoad();\n      }\n    }\n    /**\n     * use internal Image object handle fallback & placeholder\n     *\n     * @private\n     */\n\n\n    backLoad() {\n      this.backLoadImage = this.document.createElement('img');\n      this.backLoadImage.src = this.nzSrc;\n      this.backLoadImage.srcset = this.nzSrcset;\n      this.status = 'loading'; // unsubscribe last backLoad\n\n      this.backLoadDestroy$.next();\n      this.backLoadDestroy$.complete();\n      this.backLoadDestroy$ = new Subject();\n\n      if (this.backLoadImage.complete) {\n        this.status = 'normal';\n        this.getElement().nativeElement.src = this.nzSrc;\n        this.getElement().nativeElement.srcset = this.nzSrcset;\n      } else {\n        if (this.nzPlaceholder) {\n          this.getElement().nativeElement.src = this.nzPlaceholder;\n          this.getElement().nativeElement.srcset = '';\n        } else {\n          this.getElement().nativeElement.src = this.nzSrc;\n          this.getElement().nativeElement.srcset = this.nzSrcset;\n        } // The `nz-image` directive can be destroyed before the `load` or `error` event is dispatched,\n        // so there's no sense to keep capturing `this`.\n\n\n        fromEvent(this.backLoadImage, 'load').pipe(takeUntil(this.backLoadDestroy$), takeUntil(this.destroy$)).subscribe(() => {\n          this.status = 'normal';\n          this.getElement().nativeElement.src = this.nzSrc;\n          this.getElement().nativeElement.srcset = this.nzSrcset;\n        });\n        fromEvent(this.backLoadImage, 'error').pipe(takeUntil(this.backLoadDestroy$), takeUntil(this.destroy$)).subscribe(() => {\n          this.status = 'error';\n\n          if (this.nzFallback) {\n            this.getElement().nativeElement.src = this.nzFallback;\n            this.getElement().nativeElement.srcset = '';\n          }\n        });\n      }\n    }\n\n  }\n\n  NzImageDirective.ɵfac = function NzImageDirective_Factory(t) {\n    return new (t || NzImageDirective)(i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i1.NzConfigService), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NzImageService), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(NzImageGroupComponent, 8), i0.ɵɵdirectiveInject(i3$1.Directionality, 8));\n  };\n\n  NzImageDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NzImageDirective,\n    selectors: [[\"img\", \"nz-image\", \"\"]],\n    hostBindings: function NzImageDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function NzImageDirective_click_HostBindingHandler() {\n          return ctx.onPreview();\n        });\n      }\n    },\n    inputs: {\n      nzSrc: \"nzSrc\",\n      nzSrcset: \"nzSrcset\",\n      nzDisablePreview: \"nzDisablePreview\",\n      nzFallback: \"nzFallback\",\n      nzPlaceholder: \"nzPlaceholder\"\n    },\n    exportAs: [\"nzImage\"],\n    features: [i0.ɵɵNgOnChangesFeature]\n  });\n\n  __decorate([InputBoolean(), WithConfig()], NzImageDirective.prototype, \"nzDisablePreview\", void 0);\n\n  __decorate([WithConfig()], NzImageDirective.prototype, \"nzFallback\", void 0);\n\n  __decorate([WithConfig()], NzImageDirective.prototype, \"nzPlaceholder\", void 0);\n\n  return NzImageDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzImageModule = /*#__PURE__*/(() => {\n  class NzImageModule {}\n\n  NzImageModule.ɵfac = function NzImageModule_Factory(t) {\n    return new (t || NzImageModule)();\n  };\n\n  NzImageModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NzImageModule\n  });\n  NzImageModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [NzImageService],\n    imports: [[BidiModule, OverlayModule, PortalModule, DragDropModule, CommonModule, NzIconModule, NzPipesModule]]\n  });\n  return NzImageModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { FADE_CLASS_NAME_MAP, IMAGE_PREVIEW_MASK_CLASS_NAME, NZ_CONFIG_MODULE_NAME$1 as NZ_CONFIG_MODULE_NAME, NzImageDirective, NzImageGroupComponent, NzImageModule, NzImagePreviewComponent, NzImagePreviewOptions, NzImagePreviewRef, NzImageService, getClientSize, getFitContentPosition, getOffset }; //# sourceMappingURL=ng-zorro-antd-image.mjs.map","map":null,"metadata":{},"sourceType":"module"}