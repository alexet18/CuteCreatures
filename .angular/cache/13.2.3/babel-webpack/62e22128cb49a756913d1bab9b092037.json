{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nclass NzTreeNode {\n  /**\n   * Init nzTreeNode\n   *\n   * @param option: user's input\n   * @param parent\n   * @param service: base nzTreeService\n   */\n  constructor(option, parent = null, service = null) {\n    this._title = '';\n    this.level = 0; // Parent Node\n\n    this.parentNode = null;\n    this._icon = '';\n    this._children = [];\n    this._isLeaf = false;\n    this._isChecked = false;\n    this._isSelectable = false;\n    this._isDisabled = false;\n    this._isDisableCheckbox = false;\n    this._isExpanded = false;\n    this._isHalfChecked = false;\n    this._isSelected = false;\n    this._isLoading = false;\n    this.canHide = false;\n    this.isMatched = false;\n    this.service = null;\n\n    if (option instanceof NzTreeNode) {\n      return option;\n    }\n\n    this.service = service || null;\n    this.origin = option;\n    this.key = option.key;\n    this.parentNode = parent;\n    this._title = option.title || '---';\n    this._icon = option.icon || '';\n    this._isLeaf = option.isLeaf || false;\n    this._children = []; // option params\n\n    this._isChecked = option.checked || false;\n    this._isSelectable = option.disabled || option.selectable !== false;\n    this._isDisabled = option.disabled || false;\n    this._isDisableCheckbox = option.disableCheckbox || false;\n    this._isExpanded = option.isLeaf ? false : option.expanded || false;\n    this._isHalfChecked = false;\n    this._isSelected = !option.disabled && option.selected || false;\n    this._isLoading = false;\n    this.isMatched = false;\n    /**\n     * parent's checked status will affect children while initializing\n     */\n\n    if (parent) {\n      this.level = parent.level + 1;\n    } else {\n      this.level = 0;\n    }\n\n    if (typeof option.children !== 'undefined' && option.children !== null) {\n      option.children.forEach(nodeOptions => {\n        const s = this.treeService;\n\n        if (s && !s.isCheckStrictly && option.checked && !option.disabled && !nodeOptions.disabled && !nodeOptions.disableCheckbox) {\n          nodeOptions.checked = option.checked;\n        }\n\n        this._children.push(new NzTreeNode(nodeOptions, this));\n      });\n    }\n  }\n\n  get treeService() {\n    return this.service || this.parentNode && this.parentNode.treeService;\n  }\n  /**\n   * auto generate\n   * get\n   * set\n   */\n\n\n  get title() {\n    return this._title;\n  }\n\n  set title(value) {\n    this._title = value;\n    this.update();\n  }\n\n  get icon() {\n    return this._icon;\n  }\n\n  set icon(value) {\n    this._icon = value;\n    this.update();\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  set children(value) {\n    this._children = value;\n    this.update();\n  }\n\n  get isLeaf() {\n    return this._isLeaf;\n  }\n\n  set isLeaf(value) {\n    this._isLeaf = value;\n    this.update();\n  }\n\n  get isChecked() {\n    return this._isChecked;\n  }\n\n  set isChecked(value) {\n    this._isChecked = value;\n    this.origin.checked = value;\n    this.afterValueChange('isChecked');\n  }\n\n  get isHalfChecked() {\n    return this._isHalfChecked;\n  }\n\n  set isHalfChecked(value) {\n    this._isHalfChecked = value;\n    this.afterValueChange('isHalfChecked');\n  }\n\n  get isSelectable() {\n    return this._isSelectable;\n  }\n\n  set isSelectable(value) {\n    this._isSelectable = value;\n    this.update();\n  }\n\n  get isDisabled() {\n    return this._isDisabled;\n  }\n\n  set isDisabled(value) {\n    this._isDisabled = value;\n    this.update();\n  }\n\n  get isDisableCheckbox() {\n    return this._isDisableCheckbox;\n  }\n\n  set isDisableCheckbox(value) {\n    this._isDisableCheckbox = value;\n    this.update();\n  }\n\n  get isExpanded() {\n    return this._isExpanded;\n  }\n\n  set isExpanded(value) {\n    this._isExpanded = value;\n    this.origin.expanded = value;\n    this.afterValueChange('isExpanded');\n    this.afterValueChange('reRender');\n  }\n\n  get isSelected() {\n    return this._isSelected;\n  }\n\n  set isSelected(value) {\n    this._isSelected = value;\n    this.origin.selected = value;\n    this.afterValueChange('isSelected');\n  }\n\n  get isLoading() {\n    return this._isLoading;\n  }\n\n  set isLoading(value) {\n    this._isLoading = value;\n    this.update();\n  }\n\n  setSyncChecked(checked = false, halfChecked = false) {\n    this.setChecked(checked, halfChecked);\n\n    if (this.treeService && !this.treeService.isCheckStrictly) {\n      this.treeService.conduct(this);\n    }\n  }\n\n  setChecked(checked = false, halfChecked = false) {\n    this.origin.checked = checked;\n    this.isChecked = checked;\n    this.isHalfChecked = halfChecked;\n  }\n\n  setExpanded(value) {\n    this._isExpanded = value;\n    this.origin.expanded = value;\n    this.afterValueChange('isExpanded');\n  }\n\n  getParentNode() {\n    return this.parentNode;\n  }\n\n  getChildren() {\n    return this.children;\n  }\n  /**\n   * Support appending child nodes by position. Leaf node cannot be appended.\n   */\n\n\n  addChildren(children, childPos = -1) {\n    if (!this.isLeaf) {\n      children.forEach(node => {\n        const refreshLevel = n => {\n          n.getChildren().forEach(c => {\n            c.level = c.getParentNode().level + 1; // flush origin\n\n            c.origin.level = c.level;\n            refreshLevel(c);\n          });\n        };\n\n        let child = node;\n\n        if (child instanceof NzTreeNode) {\n          child.parentNode = this;\n        } else {\n          child = new NzTreeNode(node, this);\n        }\n\n        child.level = this.level + 1;\n        child.origin.level = child.level;\n        refreshLevel(child);\n\n        try {\n          childPos === -1 ? this.children.push(child) : this.children.splice(childPos, 0, child); // flush origin\n        } catch (e) {}\n      });\n      this.origin.children = this.getChildren().map(v => v.origin); // remove loading state\n\n      this.isLoading = false;\n    }\n\n    this.afterValueChange('addChildren');\n    this.afterValueChange('reRender');\n  }\n\n  clearChildren() {\n    // refresh checked state\n    this.afterValueChange('clearChildren');\n    this.children = [];\n    this.origin.children = [];\n    this.afterValueChange('reRender');\n  }\n\n  remove() {\n    const parentNode = this.getParentNode();\n\n    if (parentNode) {\n      parentNode.children = parentNode.getChildren().filter(v => v.key !== this.key);\n      parentNode.origin.children = parentNode.origin.children.filter(v => v.key !== this.key);\n      this.afterValueChange('remove');\n      this.afterValueChange('reRender');\n    }\n  }\n\n  afterValueChange(key) {\n    if (this.treeService) {\n      switch (key) {\n        case 'isChecked':\n          this.treeService.setCheckedNodeList(this);\n          break;\n\n        case 'isHalfChecked':\n          this.treeService.setHalfCheckedNodeList(this);\n          break;\n\n        case 'isExpanded':\n          this.treeService.setExpandedNodeList(this);\n          break;\n\n        case 'isSelected':\n          this.treeService.setNodeActive(this);\n          break;\n\n        case 'clearChildren':\n          this.treeService.afterRemove(this.getChildren());\n          break;\n\n        case 'remove':\n          this.treeService.afterRemove([this]);\n          break;\n\n        case 'reRender':\n          this.treeService.flattenTreeData(this.treeService.rootNodes, this.treeService.getExpandedNodeList().map(v => v.key));\n          break;\n      }\n    }\n\n    this.update();\n  }\n\n  update() {\n    if (this.component) {\n      this.component.markForCheck();\n    }\n  }\n\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction isCheckDisabled(node) {\n  const {\n    isDisabled,\n    isDisableCheckbox\n  } = node;\n  return !!(isDisabled || isDisableCheckbox);\n}\n\nfunction isInArray(needle, haystack) {\n  return haystack.length > 0 && haystack.indexOf(needle) > -1;\n}\n\nfunction getPosition(level, index) {\n  return `${level}-${index}`;\n}\n\nfunction getKey(key, pos) {\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n\n  return pos;\n}\n/**\n * Flat nest tree data into flatten list. This is used for virtual list render.\n *\n * @param treeNodeList Origin data node list\n * @param expandedKeys\n * need expanded keys, provides `true` means all expanded (used in `rc-tree-select`).\n */\n\n\nfunction flattenTreeData(treeNodeList = [], expandedKeys = []) {\n  const expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);\n  const flattenList = [];\n\n  function dig(list, parent = null) {\n    return list.map((treeNode, index) => {\n      const pos = getPosition(parent ? parent.pos : '0', index);\n      const mergedKey = getKey(treeNode.key, pos);\n      treeNode.isStart = [...(parent ? parent.isStart : []), index === 0];\n      treeNode.isEnd = [...(parent ? parent.isEnd : []), index === list.length - 1]; // Add FlattenDataNode into list\n      // TODO: only need data here.\n\n      const flattenNode = {\n        parent,\n        pos,\n        children: [],\n        data: treeNode,\n        isStart: [...(parent ? parent.isStart : []), index === 0],\n        isEnd: [...(parent ? parent.isEnd : []), index === list.length - 1]\n      };\n      flattenList.push(flattenNode); // Loop treeNode children\n\n      if (expandedKeys === true || expandedKeySet.has(mergedKey) || treeNode.isExpanded) {\n        flattenNode.children = dig(treeNode.children || [], flattenNode);\n      } else {\n        flattenNode.children = [];\n      }\n\n      return flattenNode;\n    });\n  }\n\n  dig(treeNodeList);\n  return flattenList;\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nclass NzTreeBaseService {\n  constructor() {\n    this.DRAG_SIDE_RANGE = 0.25;\n    this.DRAG_MIN_GAP = 2;\n    this.isCheckStrictly = false;\n    this.isMultiple = false;\n    this.rootNodes = [];\n    this.flattenNodes$ = new BehaviorSubject([]);\n    this.selectedNodeList = [];\n    this.expandedNodeList = [];\n    this.checkedNodeList = [];\n    this.halfCheckedNodeList = [];\n    this.matchedNodeList = [];\n  }\n  /**\n   * reset tree nodes will clear default node list\n   */\n\n\n  initTree(nzNodes) {\n    this.rootNodes = nzNodes;\n    this.expandedNodeList = [];\n    this.selectedNodeList = [];\n    this.halfCheckedNodeList = [];\n    this.checkedNodeList = [];\n    this.matchedNodeList = [];\n  }\n\n  flattenTreeData(nzNodes, expandedKeys = []) {\n    this.flattenNodes$.next(flattenTreeData(nzNodes, expandedKeys).map(item => item.data));\n  }\n\n  getSelectedNode() {\n    return this.selectedNode;\n  }\n  /**\n   * get some list\n   */\n\n\n  getSelectedNodeList() {\n    return this.conductNodeState('select');\n  }\n  /**\n   * return checked nodes\n   */\n\n\n  getCheckedNodeList() {\n    return this.conductNodeState('check');\n  }\n\n  getHalfCheckedNodeList() {\n    return this.conductNodeState('halfCheck');\n  }\n  /**\n   * return expanded nodes\n   */\n\n\n  getExpandedNodeList() {\n    return this.conductNodeState('expand');\n  }\n  /**\n   * return search matched nodes\n   */\n\n\n  getMatchedNodeList() {\n    return this.conductNodeState('match');\n  }\n\n  isArrayOfNzTreeNode(value) {\n    return value.every(item => item instanceof NzTreeNode);\n  }\n  /**\n   * set drag node\n   */\n\n\n  setSelectedNode(node) {\n    this.selectedNode = node;\n  }\n  /**\n   * set node selected status\n   */\n\n\n  setNodeActive(node) {\n    if (!this.isMultiple && node.isSelected) {\n      this.selectedNodeList.forEach(n => {\n        if (node.key !== n.key) {\n          // reset other nodes\n          n.isSelected = false;\n        }\n      }); // single mode: remove pre node\n\n      this.selectedNodeList = [];\n    }\n\n    this.setSelectedNodeList(node, this.isMultiple);\n  }\n  /**\n   * add or remove node to selectedNodeList\n   */\n\n\n  setSelectedNodeList(node, isMultiple = false) {\n    const index = this.getIndexOfArray(this.selectedNodeList, node.key);\n\n    if (isMultiple) {\n      if (node.isSelected && index === -1) {\n        this.selectedNodeList.push(node);\n      }\n    } else {\n      if (node.isSelected && index === -1) {\n        this.selectedNodeList = [node];\n      }\n    }\n\n    if (!node.isSelected) {\n      this.selectedNodeList = this.selectedNodeList.filter(n => n.key !== node.key);\n    }\n  }\n  /**\n   * merge checked nodes\n   */\n\n\n  setHalfCheckedNodeList(node) {\n    const index = this.getIndexOfArray(this.halfCheckedNodeList, node.key);\n\n    if (node.isHalfChecked && index === -1) {\n      this.halfCheckedNodeList.push(node);\n    } else if (!node.isHalfChecked && index > -1) {\n      this.halfCheckedNodeList = this.halfCheckedNodeList.filter(n => node.key !== n.key);\n    }\n  }\n\n  setCheckedNodeList(node) {\n    const index = this.getIndexOfArray(this.checkedNodeList, node.key);\n\n    if (node.isChecked && index === -1) {\n      this.checkedNodeList.push(node);\n    } else if (!node.isChecked && index > -1) {\n      this.checkedNodeList = this.checkedNodeList.filter(n => node.key !== n.key);\n    }\n  }\n  /**\n   * conduct checked/selected/expanded keys\n   */\n\n\n  conductNodeState(type = 'check') {\n    let resultNodesList = [];\n\n    switch (type) {\n      case 'select':\n        resultNodesList = this.selectedNodeList;\n        break;\n\n      case 'expand':\n        resultNodesList = this.expandedNodeList;\n        break;\n\n      case 'match':\n        resultNodesList = this.matchedNodeList;\n        break;\n\n      case 'check':\n        resultNodesList = this.checkedNodeList;\n\n        const isIgnore = node => {\n          const parentNode = node.getParentNode();\n\n          if (parentNode) {\n            if (this.checkedNodeList.findIndex(n => n.key === parentNode.key) > -1) {\n              return true;\n            } else {\n              return isIgnore(parentNode);\n            }\n          }\n\n          return false;\n        }; // merge checked\n\n\n        if (!this.isCheckStrictly) {\n          resultNodesList = this.checkedNodeList.filter(n => !isIgnore(n));\n        }\n\n        break;\n\n      case 'halfCheck':\n        if (!this.isCheckStrictly) {\n          resultNodesList = this.halfCheckedNodeList;\n        }\n\n        break;\n    }\n\n    return resultNodesList;\n  }\n  /**\n   * set expanded nodes\n   */\n\n\n  setExpandedNodeList(node) {\n    if (node.isLeaf) {\n      return;\n    }\n\n    const index = this.getIndexOfArray(this.expandedNodeList, node.key);\n\n    if (node.isExpanded && index === -1) {\n      this.expandedNodeList.push(node);\n    } else if (!node.isExpanded && index > -1) {\n      this.expandedNodeList.splice(index, 1);\n    }\n  }\n\n  setMatchedNodeList(node) {\n    const index = this.getIndexOfArray(this.matchedNodeList, node.key);\n\n    if (node.isMatched && index === -1) {\n      this.matchedNodeList.push(node);\n    } else if (!node.isMatched && index > -1) {\n      this.matchedNodeList.splice(index, 1);\n    }\n  }\n  /**\n   * check state\n   *\n   * @param isCheckStrictly\n   */\n\n\n  refreshCheckState(isCheckStrictly = false) {\n    if (isCheckStrictly) {\n      return;\n    }\n\n    this.checkedNodeList.forEach(node => {\n      this.conduct(node, isCheckStrictly);\n    });\n  } // reset other node checked state based current node\n\n\n  conduct(node, isCheckStrictly = false) {\n    const isChecked = node.isChecked;\n\n    if (node && !isCheckStrictly) {\n      this.conductUp(node);\n      this.conductDown(node, isChecked);\n    }\n  }\n  /**\n   * 1、children half checked\n   * 2、children all checked, parent checked\n   * 3、no children checked\n   */\n\n\n  conductUp(node) {\n    const parentNode = node.getParentNode();\n\n    if (parentNode) {\n      if (!isCheckDisabled(parentNode)) {\n        if (parentNode.children.every(child => isCheckDisabled(child) || !child.isHalfChecked && child.isChecked)) {\n          parentNode.isChecked = true;\n          parentNode.isHalfChecked = false;\n        } else if (parentNode.children.some(child => child.isHalfChecked || child.isChecked)) {\n          parentNode.isChecked = false;\n          parentNode.isHalfChecked = true;\n        } else {\n          parentNode.isChecked = false;\n          parentNode.isHalfChecked = false;\n        }\n      }\n\n      this.setCheckedNodeList(parentNode);\n      this.setHalfCheckedNodeList(parentNode);\n      this.conductUp(parentNode);\n    }\n  }\n  /**\n   * reset child check state\n   */\n\n\n  conductDown(node, value) {\n    if (!isCheckDisabled(node)) {\n      node.isChecked = value;\n      node.isHalfChecked = false;\n      this.setCheckedNodeList(node);\n      this.setHalfCheckedNodeList(node);\n      node.children.forEach(n => {\n        this.conductDown(n, value);\n      });\n    }\n  }\n  /**\n   * flush after delete node\n   */\n\n\n  afterRemove(nodes) {\n    // to reset selectedNodeList & expandedNodeList\n    const loopNode = node => {\n      // remove selected node\n      this.selectedNodeList = this.selectedNodeList.filter(n => n.key !== node.key); // remove expanded node\n\n      this.expandedNodeList = this.expandedNodeList.filter(n => n.key !== node.key); // remove checked node\n\n      this.checkedNodeList = this.checkedNodeList.filter(n => n.key !== node.key);\n\n      if (node.children) {\n        node.children.forEach(child => {\n          loopNode(child);\n        });\n      }\n    };\n\n    nodes.forEach(n => {\n      loopNode(n);\n    });\n    this.refreshCheckState(this.isCheckStrictly);\n  }\n  /**\n   * drag event\n   */\n\n\n  refreshDragNode(node) {\n    if (node.children.length === 0) {\n      // until root\n      this.conductUp(node);\n    } else {\n      node.children.forEach(child => {\n        this.refreshDragNode(child);\n      });\n    }\n  } // reset node level\n\n\n  resetNodeLevel(node) {\n    const parentNode = node.getParentNode();\n\n    if (parentNode) {\n      node.level = parentNode.level + 1;\n    } else {\n      node.level = 0;\n    }\n\n    for (const child of node.children) {\n      this.resetNodeLevel(child);\n    }\n  }\n\n  calcDropPosition(event) {\n    const {\n      clientY\n    } = event; // to fix firefox undefined\n\n    const {\n      top,\n      bottom,\n      height\n    } = event.target.getBoundingClientRect();\n    const des = Math.max(height * this.DRAG_SIDE_RANGE, this.DRAG_MIN_GAP);\n\n    if (clientY <= top + des) {\n      return -1;\n    } else if (clientY >= bottom - des) {\n      return 1;\n    }\n\n    return 0;\n  }\n  /**\n   * drop\n   * 0: inner -1: pre 1: next\n   */\n\n\n  dropAndApply(targetNode, dragPos = -1) {\n    if (!targetNode || dragPos > 1) {\n      return;\n    }\n\n    const treeService = targetNode.treeService;\n    const targetParent = targetNode.getParentNode();\n    const isSelectedRootNode = this.selectedNode.getParentNode(); // remove the dragNode\n\n    if (isSelectedRootNode) {\n      isSelectedRootNode.children = isSelectedRootNode.children.filter(n => n.key !== this.selectedNode.key);\n    } else {\n      this.rootNodes = this.rootNodes.filter(n => n.key !== this.selectedNode.key);\n    }\n\n    switch (dragPos) {\n      case 0:\n        targetNode.addChildren([this.selectedNode]);\n        this.resetNodeLevel(targetNode);\n        break;\n\n      case -1:\n      case 1:\n        const tIndex = dragPos === 1 ? 1 : 0;\n\n        if (targetParent) {\n          targetParent.addChildren([this.selectedNode], targetParent.children.indexOf(targetNode) + tIndex);\n          const parentNode = this.selectedNode.getParentNode();\n\n          if (parentNode) {\n            this.resetNodeLevel(parentNode);\n          }\n        } else {\n          const targetIndex = this.rootNodes.indexOf(targetNode) + tIndex; // Insert root node.\n\n          this.rootNodes.splice(targetIndex, 0, this.selectedNode);\n          this.rootNodes[targetIndex].parentNode = null;\n          this.resetNodeLevel(this.rootNodes[targetIndex]);\n        }\n\n        break;\n    } // flush all nodes\n\n\n    this.rootNodes.forEach(child => {\n      if (!child.treeService) {\n        child.service = treeService;\n      }\n\n      this.refreshDragNode(child);\n    });\n  }\n  /**\n   * emit Structure\n   * eventName\n   * node\n   * event: MouseEvent / DragEvent\n   * dragNode\n   */\n\n\n  formatEvent(eventName, node, event) {\n    const emitStructure = {\n      eventName,\n      node,\n      event\n    };\n\n    switch (eventName) {\n      case 'dragstart':\n      case 'dragenter':\n      case 'dragover':\n      case 'dragleave':\n      case 'drop':\n      case 'dragend':\n        Object.assign(emitStructure, {\n          dragNode: this.getSelectedNode()\n        });\n        break;\n\n      case 'click':\n      case 'dblclick':\n        Object.assign(emitStructure, {\n          selectedKeys: this.selectedNodeList\n        });\n        Object.assign(emitStructure, {\n          nodes: this.selectedNodeList\n        });\n        Object.assign(emitStructure, {\n          keys: this.selectedNodeList.map(n => n.key)\n        });\n        break;\n\n      case 'check':\n        const checkedNodeList = this.getCheckedNodeList();\n        Object.assign(emitStructure, {\n          checkedKeys: checkedNodeList\n        });\n        Object.assign(emitStructure, {\n          nodes: checkedNodeList\n        });\n        Object.assign(emitStructure, {\n          keys: checkedNodeList.map(n => n.key)\n        });\n        break;\n\n      case 'search':\n        Object.assign(emitStructure, {\n          matchedKeys: this.getMatchedNodeList()\n        });\n        Object.assign(emitStructure, {\n          nodes: this.getMatchedNodeList()\n        });\n        Object.assign(emitStructure, {\n          keys: this.getMatchedNodeList().map(n => n.key)\n        });\n        break;\n\n      case 'expand':\n        Object.assign(emitStructure, {\n          nodes: this.expandedNodeList\n        });\n        Object.assign(emitStructure, {\n          keys: this.expandedNodeList.map(n => n.key)\n        });\n        break;\n    }\n\n    return emitStructure;\n  }\n  /**\n   * New functions for flatten nodes\n   */\n\n\n  getIndexOfArray(list, key) {\n    return list.findIndex(v => v.key === key);\n  }\n  /**\n   * Render by nzCheckedKeys\n   * When keys equals null, just render with checkStrictly\n   *\n   * @param keys\n   * @param checkStrictly\n   */\n\n\n  conductCheck(keys, checkStrictly) {\n    this.checkedNodeList = [];\n    this.halfCheckedNodeList = [];\n\n    const calc = nodes => {\n      nodes.forEach(node => {\n        if (keys === null) {\n          // render tree if no default checked keys found\n          node.isChecked = !!node.origin.checked;\n        } else {\n          if (isInArray(node.key, keys || [])) {\n            node.isChecked = true;\n            node.isHalfChecked = false;\n          } else {\n            node.isChecked = false;\n            node.isHalfChecked = false;\n          }\n        }\n\n        if (node.children.length > 0) {\n          calc(node.children);\n        }\n      });\n    };\n\n    calc(this.rootNodes);\n    this.refreshCheckState(checkStrictly);\n  }\n\n  conductExpandedKeys(keys = []) {\n    const expandedKeySet = new Set(keys === true ? [] : keys);\n    this.expandedNodeList = [];\n\n    const calc = nodes => {\n      nodes.forEach(node => {\n        node.setExpanded(keys === true || expandedKeySet.has(node.key) || node.isExpanded === true);\n\n        if (node.isExpanded) {\n          this.setExpandedNodeList(node);\n        }\n\n        if (node.children.length > 0) {\n          calc(node.children);\n        }\n      });\n    };\n\n    calc(this.rootNodes);\n  }\n\n  conductSelectedKeys(keys, isMulti) {\n    this.selectedNodeList.forEach(node => node.isSelected = false);\n    this.selectedNodeList = [];\n\n    const calc = nodes => nodes.every(node => {\n      if (isInArray(node.key, keys)) {\n        node.isSelected = true;\n        this.setSelectedNodeList(node);\n\n        if (!isMulti) {\n          // if not support multi select\n          return false;\n        }\n      } else {\n        node.isSelected = false;\n      }\n\n      if (node.children.length > 0) {\n        // Recursion\n        return calc(node.children);\n      }\n\n      return true;\n    });\n\n    calc(this.rootNodes);\n  }\n  /**\n   * Expand parent nodes by child node\n   *\n   * @param node\n   */\n\n\n  expandNodeAllParentBySearch(node) {\n    const calc = n => {\n      if (n) {\n        n.canHide = false;\n        n.setExpanded(true);\n        this.setExpandedNodeList(n);\n\n        if (n.getParentNode()) {\n          return calc(n.getParentNode());\n        }\n      }\n    };\n\n    calc(node.getParentNode());\n  }\n\n}\n\nNzTreeBaseService.ɵfac = function NzTreeBaseService_Factory(t) {\n  return new (t || NzTreeBaseService)();\n};\n\nNzTreeBaseService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: NzTreeBaseService,\n  factory: NzTreeBaseService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NzTreeBaseService, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nconst NzTreeHigherOrderServiceToken = new InjectionToken('NzTreeHigherOrder');\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nclass NzTreeBase {\n  constructor(nzTreeService) {\n    this.nzTreeService = nzTreeService;\n  }\n  /**\n   * Coerces a value({@link any[]}) to a TreeNodes({@link NzTreeNode[]})\n   */\n\n\n  coerceTreeNodes(value) {\n    let nodes = [];\n\n    if (!this.nzTreeService.isArrayOfNzTreeNode(value)) {\n      // has not been new NzTreeNode\n      nodes = value.map(item => new NzTreeNode(item, null, this.nzTreeService));\n    } else {\n      nodes = value.map(item => {\n        item.service = this.nzTreeService;\n        return item;\n      });\n    }\n\n    return nodes;\n  }\n  /**\n   * Get all nodes({@link NzTreeNode})\n   */\n\n\n  getTreeNodes() {\n    return this.nzTreeService.rootNodes;\n  }\n  /**\n   * Get {@link NzTreeNode} with key\n   */\n\n\n  getTreeNodeByKey(key) {\n    // flat tree nodes\n    const nodes = [];\n\n    const getNode = node => {\n      nodes.push(node);\n      node.getChildren().forEach(n => {\n        getNode(n);\n      });\n    };\n\n    this.getTreeNodes().forEach(n => {\n      getNode(n);\n    });\n    return nodes.find(n => n.key === key) || null;\n  }\n  /**\n   * Get checked nodes(merged)\n   */\n\n\n  getCheckedNodeList() {\n    return this.nzTreeService.getCheckedNodeList();\n  }\n  /**\n   * Get selected nodes\n   */\n\n\n  getSelectedNodeList() {\n    return this.nzTreeService.getSelectedNodeList();\n  }\n  /**\n   * Get half checked nodes\n   */\n\n\n  getHalfCheckedNodeList() {\n    return this.nzTreeService.getHalfCheckedNodeList();\n  }\n  /**\n   * Get expanded nodes\n   */\n\n\n  getExpandedNodeList() {\n    return this.nzTreeService.getExpandedNodeList();\n  }\n  /**\n   * Get matched nodes(if nzSearchValue is not null)\n   */\n\n\n  getMatchedNodeList() {\n    return this.nzTreeService.getMatchedNodeList();\n  }\n\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzTreeBase, NzTreeBaseService, NzTreeHigherOrderServiceToken, NzTreeNode, flattenTreeData, getKey, getPosition, isCheckDisabled, isInArray };","map":{"version":3,"sources":["/home/tudor/Desktop/Work/Git/Cute/node_modules/ng-zorro-antd/fesm2015/ng-zorro-antd-core-tree.mjs"],"names":["i0","Injectable","InjectionToken","BehaviorSubject","NzTreeNode","constructor","option","parent","service","_title","level","parentNode","_icon","_children","_isLeaf","_isChecked","_isSelectable","_isDisabled","_isDisableCheckbox","_isExpanded","_isHalfChecked","_isSelected","_isLoading","canHide","isMatched","origin","key","title","icon","isLeaf","checked","disabled","selectable","disableCheckbox","expanded","selected","children","forEach","nodeOptions","s","treeService","isCheckStrictly","push","value","update","isChecked","afterValueChange","isHalfChecked","isSelectable","isDisabled","isDisableCheckbox","isExpanded","isSelected","isLoading","setSyncChecked","halfChecked","setChecked","conduct","setExpanded","getParentNode","getChildren","addChildren","childPos","node","refreshLevel","n","c","child","splice","e","map","v","clearChildren","remove","filter","setCheckedNodeList","setHalfCheckedNodeList","setExpandedNodeList","setNodeActive","afterRemove","flattenTreeData","rootNodes","getExpandedNodeList","component","markForCheck","isCheckDisabled","isInArray","needle","haystack","length","indexOf","getPosition","index","getKey","pos","undefined","treeNodeList","expandedKeys","expandedKeySet","Set","flattenList","dig","list","treeNode","mergedKey","isStart","isEnd","flattenNode","data","has","NzTreeBaseService","DRAG_SIDE_RANGE","DRAG_MIN_GAP","isMultiple","flattenNodes$","selectedNodeList","expandedNodeList","checkedNodeList","halfCheckedNodeList","matchedNodeList","initTree","nzNodes","next","item","getSelectedNode","selectedNode","getSelectedNodeList","conductNodeState","getCheckedNodeList","getHalfCheckedNodeList","getMatchedNodeList","isArrayOfNzTreeNode","every","setSelectedNode","setSelectedNodeList","getIndexOfArray","type","resultNodesList","isIgnore","findIndex","setMatchedNodeList","refreshCheckState","conductUp","conductDown","some","nodes","loopNode","refreshDragNode","resetNodeLevel","calcDropPosition","event","clientY","top","bottom","height","target","getBoundingClientRect","des","Math","max","dropAndApply","targetNode","dragPos","targetParent","isSelectedRootNode","tIndex","targetIndex","formatEvent","eventName","emitStructure","Object","assign","dragNode","selectedKeys","keys","checkedKeys","matchedKeys","conductCheck","checkStrictly","calc","conductExpandedKeys","conductSelectedKeys","isMulti","expandNodeAllParentBySearch","ɵfac","ɵprov","NzTreeHigherOrderServiceToken","NzTreeBase","nzTreeService","coerceTreeNodes","getTreeNodes","getTreeNodeByKey","getNode","find"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTreeNode {\n    /**\n     * Init nzTreeNode\n     *\n     * @param option: user's input\n     * @param parent\n     * @param service: base nzTreeService\n     */\n    constructor(option, parent = null, service = null) {\n        this._title = '';\n        this.level = 0;\n        // Parent Node\n        this.parentNode = null;\n        this._icon = '';\n        this._children = [];\n        this._isLeaf = false;\n        this._isChecked = false;\n        this._isSelectable = false;\n        this._isDisabled = false;\n        this._isDisableCheckbox = false;\n        this._isExpanded = false;\n        this._isHalfChecked = false;\n        this._isSelected = false;\n        this._isLoading = false;\n        this.canHide = false;\n        this.isMatched = false;\n        this.service = null;\n        if (option instanceof NzTreeNode) {\n            return option;\n        }\n        this.service = service || null;\n        this.origin = option;\n        this.key = option.key;\n        this.parentNode = parent;\n        this._title = option.title || '---';\n        this._icon = option.icon || '';\n        this._isLeaf = option.isLeaf || false;\n        this._children = [];\n        // option params\n        this._isChecked = option.checked || false;\n        this._isSelectable = option.disabled || option.selectable !== false;\n        this._isDisabled = option.disabled || false;\n        this._isDisableCheckbox = option.disableCheckbox || false;\n        this._isExpanded = option.isLeaf ? false : option.expanded || false;\n        this._isHalfChecked = false;\n        this._isSelected = (!option.disabled && option.selected) || false;\n        this._isLoading = false;\n        this.isMatched = false;\n        /**\n         * parent's checked status will affect children while initializing\n         */\n        if (parent) {\n            this.level = parent.level + 1;\n        }\n        else {\n            this.level = 0;\n        }\n        if (typeof option.children !== 'undefined' && option.children !== null) {\n            option.children.forEach(nodeOptions => {\n                const s = this.treeService;\n                if (s &&\n                    !s.isCheckStrictly &&\n                    option.checked &&\n                    !option.disabled &&\n                    !nodeOptions.disabled &&\n                    !nodeOptions.disableCheckbox) {\n                    nodeOptions.checked = option.checked;\n                }\n                this._children.push(new NzTreeNode(nodeOptions, this));\n            });\n        }\n    }\n    get treeService() {\n        return this.service || (this.parentNode && this.parentNode.treeService);\n    }\n    /**\n     * auto generate\n     * get\n     * set\n     */\n    get title() {\n        return this._title;\n    }\n    set title(value) {\n        this._title = value;\n        this.update();\n    }\n    get icon() {\n        return this._icon;\n    }\n    set icon(value) {\n        this._icon = value;\n        this.update();\n    }\n    get children() {\n        return this._children;\n    }\n    set children(value) {\n        this._children = value;\n        this.update();\n    }\n    get isLeaf() {\n        return this._isLeaf;\n    }\n    set isLeaf(value) {\n        this._isLeaf = value;\n        this.update();\n    }\n    get isChecked() {\n        return this._isChecked;\n    }\n    set isChecked(value) {\n        this._isChecked = value;\n        this.origin.checked = value;\n        this.afterValueChange('isChecked');\n    }\n    get isHalfChecked() {\n        return this._isHalfChecked;\n    }\n    set isHalfChecked(value) {\n        this._isHalfChecked = value;\n        this.afterValueChange('isHalfChecked');\n    }\n    get isSelectable() {\n        return this._isSelectable;\n    }\n    set isSelectable(value) {\n        this._isSelectable = value;\n        this.update();\n    }\n    get isDisabled() {\n        return this._isDisabled;\n    }\n    set isDisabled(value) {\n        this._isDisabled = value;\n        this.update();\n    }\n    get isDisableCheckbox() {\n        return this._isDisableCheckbox;\n    }\n    set isDisableCheckbox(value) {\n        this._isDisableCheckbox = value;\n        this.update();\n    }\n    get isExpanded() {\n        return this._isExpanded;\n    }\n    set isExpanded(value) {\n        this._isExpanded = value;\n        this.origin.expanded = value;\n        this.afterValueChange('isExpanded');\n        this.afterValueChange('reRender');\n    }\n    get isSelected() {\n        return this._isSelected;\n    }\n    set isSelected(value) {\n        this._isSelected = value;\n        this.origin.selected = value;\n        this.afterValueChange('isSelected');\n    }\n    get isLoading() {\n        return this._isLoading;\n    }\n    set isLoading(value) {\n        this._isLoading = value;\n        this.update();\n    }\n    setSyncChecked(checked = false, halfChecked = false) {\n        this.setChecked(checked, halfChecked);\n        if (this.treeService && !this.treeService.isCheckStrictly) {\n            this.treeService.conduct(this);\n        }\n    }\n    setChecked(checked = false, halfChecked = false) {\n        this.origin.checked = checked;\n        this.isChecked = checked;\n        this.isHalfChecked = halfChecked;\n    }\n    setExpanded(value) {\n        this._isExpanded = value;\n        this.origin.expanded = value;\n        this.afterValueChange('isExpanded');\n    }\n    getParentNode() {\n        return this.parentNode;\n    }\n    getChildren() {\n        return this.children;\n    }\n    /**\n     * Support appending child nodes by position. Leaf node cannot be appended.\n     */\n    addChildren(children, childPos = -1) {\n        if (!this.isLeaf) {\n            children.forEach(node => {\n                const refreshLevel = (n) => {\n                    n.getChildren().forEach(c => {\n                        c.level = c.getParentNode().level + 1;\n                        // flush origin\n                        c.origin.level = c.level;\n                        refreshLevel(c);\n                    });\n                };\n                let child = node;\n                if (child instanceof NzTreeNode) {\n                    child.parentNode = this;\n                }\n                else {\n                    child = new NzTreeNode(node, this);\n                }\n                child.level = this.level + 1;\n                child.origin.level = child.level;\n                refreshLevel(child);\n                try {\n                    childPos === -1 ? this.children.push(child) : this.children.splice(childPos, 0, child);\n                    // flush origin\n                }\n                catch (e) { }\n            });\n            this.origin.children = this.getChildren().map(v => v.origin);\n            // remove loading state\n            this.isLoading = false;\n        }\n        this.afterValueChange('addChildren');\n        this.afterValueChange('reRender');\n    }\n    clearChildren() {\n        // refresh checked state\n        this.afterValueChange('clearChildren');\n        this.children = [];\n        this.origin.children = [];\n        this.afterValueChange('reRender');\n    }\n    remove() {\n        const parentNode = this.getParentNode();\n        if (parentNode) {\n            parentNode.children = parentNode.getChildren().filter(v => v.key !== this.key);\n            parentNode.origin.children = parentNode.origin.children.filter(v => v.key !== this.key);\n            this.afterValueChange('remove');\n            this.afterValueChange('reRender');\n        }\n    }\n    afterValueChange(key) {\n        if (this.treeService) {\n            switch (key) {\n                case 'isChecked':\n                    this.treeService.setCheckedNodeList(this);\n                    break;\n                case 'isHalfChecked':\n                    this.treeService.setHalfCheckedNodeList(this);\n                    break;\n                case 'isExpanded':\n                    this.treeService.setExpandedNodeList(this);\n                    break;\n                case 'isSelected':\n                    this.treeService.setNodeActive(this);\n                    break;\n                case 'clearChildren':\n                    this.treeService.afterRemove(this.getChildren());\n                    break;\n                case 'remove':\n                    this.treeService.afterRemove([this]);\n                    break;\n                case 'reRender':\n                    this.treeService.flattenTreeData(this.treeService.rootNodes, this.treeService.getExpandedNodeList().map(v => v.key));\n                    break;\n            }\n        }\n        this.update();\n    }\n    update() {\n        if (this.component) {\n            this.component.markForCheck();\n        }\n    }\n}\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nfunction isCheckDisabled(node) {\n    const { isDisabled, isDisableCheckbox } = node;\n    return !!(isDisabled || isDisableCheckbox);\n}\nfunction isInArray(needle, haystack) {\n    return haystack.length > 0 && haystack.indexOf(needle) > -1;\n}\nfunction getPosition(level, index) {\n    return `${level}-${index}`;\n}\nfunction getKey(key, pos) {\n    if (key !== null && key !== undefined) {\n        return key;\n    }\n    return pos;\n}\n/**\n * Flat nest tree data into flatten list. This is used for virtual list render.\n *\n * @param treeNodeList Origin data node list\n * @param expandedKeys\n * need expanded keys, provides `true` means all expanded (used in `rc-tree-select`).\n */\nfunction flattenTreeData(treeNodeList = [], expandedKeys = []) {\n    const expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);\n    const flattenList = [];\n    function dig(list, parent = null) {\n        return list.map((treeNode, index) => {\n            const pos = getPosition(parent ? parent.pos : '0', index);\n            const mergedKey = getKey(treeNode.key, pos);\n            treeNode.isStart = [...(parent ? parent.isStart : []), index === 0];\n            treeNode.isEnd = [...(parent ? parent.isEnd : []), index === list.length - 1];\n            // Add FlattenDataNode into list\n            // TODO: only need data here.\n            const flattenNode = {\n                parent,\n                pos,\n                children: [],\n                data: treeNode,\n                isStart: [...(parent ? parent.isStart : []), index === 0],\n                isEnd: [...(parent ? parent.isEnd : []), index === list.length - 1]\n            };\n            flattenList.push(flattenNode);\n            // Loop treeNode children\n            if (expandedKeys === true || expandedKeySet.has(mergedKey) || treeNode.isExpanded) {\n                flattenNode.children = dig(treeNode.children || [], flattenNode);\n            }\n            else {\n                flattenNode.children = [];\n            }\n            return flattenNode;\n        });\n    }\n    dig(treeNodeList);\n    return flattenList;\n}\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTreeBaseService {\n    constructor() {\n        this.DRAG_SIDE_RANGE = 0.25;\n        this.DRAG_MIN_GAP = 2;\n        this.isCheckStrictly = false;\n        this.isMultiple = false;\n        this.rootNodes = [];\n        this.flattenNodes$ = new BehaviorSubject([]);\n        this.selectedNodeList = [];\n        this.expandedNodeList = [];\n        this.checkedNodeList = [];\n        this.halfCheckedNodeList = [];\n        this.matchedNodeList = [];\n    }\n    /**\n     * reset tree nodes will clear default node list\n     */\n    initTree(nzNodes) {\n        this.rootNodes = nzNodes;\n        this.expandedNodeList = [];\n        this.selectedNodeList = [];\n        this.halfCheckedNodeList = [];\n        this.checkedNodeList = [];\n        this.matchedNodeList = [];\n    }\n    flattenTreeData(nzNodes, expandedKeys = []) {\n        this.flattenNodes$.next(flattenTreeData(nzNodes, expandedKeys).map(item => item.data));\n    }\n    getSelectedNode() {\n        return this.selectedNode;\n    }\n    /**\n     * get some list\n     */\n    getSelectedNodeList() {\n        return this.conductNodeState('select');\n    }\n    /**\n     * return checked nodes\n     */\n    getCheckedNodeList() {\n        return this.conductNodeState('check');\n    }\n    getHalfCheckedNodeList() {\n        return this.conductNodeState('halfCheck');\n    }\n    /**\n     * return expanded nodes\n     */\n    getExpandedNodeList() {\n        return this.conductNodeState('expand');\n    }\n    /**\n     * return search matched nodes\n     */\n    getMatchedNodeList() {\n        return this.conductNodeState('match');\n    }\n    isArrayOfNzTreeNode(value) {\n        return value.every(item => item instanceof NzTreeNode);\n    }\n    /**\n     * set drag node\n     */\n    setSelectedNode(node) {\n        this.selectedNode = node;\n    }\n    /**\n     * set node selected status\n     */\n    setNodeActive(node) {\n        if (!this.isMultiple && node.isSelected) {\n            this.selectedNodeList.forEach(n => {\n                if (node.key !== n.key) {\n                    // reset other nodes\n                    n.isSelected = false;\n                }\n            });\n            // single mode: remove pre node\n            this.selectedNodeList = [];\n        }\n        this.setSelectedNodeList(node, this.isMultiple);\n    }\n    /**\n     * add or remove node to selectedNodeList\n     */\n    setSelectedNodeList(node, isMultiple = false) {\n        const index = this.getIndexOfArray(this.selectedNodeList, node.key);\n        if (isMultiple) {\n            if (node.isSelected && index === -1) {\n                this.selectedNodeList.push(node);\n            }\n        }\n        else {\n            if (node.isSelected && index === -1) {\n                this.selectedNodeList = [node];\n            }\n        }\n        if (!node.isSelected) {\n            this.selectedNodeList = this.selectedNodeList.filter(n => n.key !== node.key);\n        }\n    }\n    /**\n     * merge checked nodes\n     */\n    setHalfCheckedNodeList(node) {\n        const index = this.getIndexOfArray(this.halfCheckedNodeList, node.key);\n        if (node.isHalfChecked && index === -1) {\n            this.halfCheckedNodeList.push(node);\n        }\n        else if (!node.isHalfChecked && index > -1) {\n            this.halfCheckedNodeList = this.halfCheckedNodeList.filter(n => node.key !== n.key);\n        }\n    }\n    setCheckedNodeList(node) {\n        const index = this.getIndexOfArray(this.checkedNodeList, node.key);\n        if (node.isChecked && index === -1) {\n            this.checkedNodeList.push(node);\n        }\n        else if (!node.isChecked && index > -1) {\n            this.checkedNodeList = this.checkedNodeList.filter(n => node.key !== n.key);\n        }\n    }\n    /**\n     * conduct checked/selected/expanded keys\n     */\n    conductNodeState(type = 'check') {\n        let resultNodesList = [];\n        switch (type) {\n            case 'select':\n                resultNodesList = this.selectedNodeList;\n                break;\n            case 'expand':\n                resultNodesList = this.expandedNodeList;\n                break;\n            case 'match':\n                resultNodesList = this.matchedNodeList;\n                break;\n            case 'check':\n                resultNodesList = this.checkedNodeList;\n                const isIgnore = (node) => {\n                    const parentNode = node.getParentNode();\n                    if (parentNode) {\n                        if (this.checkedNodeList.findIndex(n => n.key === parentNode.key) > -1) {\n                            return true;\n                        }\n                        else {\n                            return isIgnore(parentNode);\n                        }\n                    }\n                    return false;\n                };\n                // merge checked\n                if (!this.isCheckStrictly) {\n                    resultNodesList = this.checkedNodeList.filter(n => !isIgnore(n));\n                }\n                break;\n            case 'halfCheck':\n                if (!this.isCheckStrictly) {\n                    resultNodesList = this.halfCheckedNodeList;\n                }\n                break;\n        }\n        return resultNodesList;\n    }\n    /**\n     * set expanded nodes\n     */\n    setExpandedNodeList(node) {\n        if (node.isLeaf) {\n            return;\n        }\n        const index = this.getIndexOfArray(this.expandedNodeList, node.key);\n        if (node.isExpanded && index === -1) {\n            this.expandedNodeList.push(node);\n        }\n        else if (!node.isExpanded && index > -1) {\n            this.expandedNodeList.splice(index, 1);\n        }\n    }\n    setMatchedNodeList(node) {\n        const index = this.getIndexOfArray(this.matchedNodeList, node.key);\n        if (node.isMatched && index === -1) {\n            this.matchedNodeList.push(node);\n        }\n        else if (!node.isMatched && index > -1) {\n            this.matchedNodeList.splice(index, 1);\n        }\n    }\n    /**\n     * check state\n     *\n     * @param isCheckStrictly\n     */\n    refreshCheckState(isCheckStrictly = false) {\n        if (isCheckStrictly) {\n            return;\n        }\n        this.checkedNodeList.forEach(node => {\n            this.conduct(node, isCheckStrictly);\n        });\n    }\n    // reset other node checked state based current node\n    conduct(node, isCheckStrictly = false) {\n        const isChecked = node.isChecked;\n        if (node && !isCheckStrictly) {\n            this.conductUp(node);\n            this.conductDown(node, isChecked);\n        }\n    }\n    /**\n     * 1、children half checked\n     * 2、children all checked, parent checked\n     * 3、no children checked\n     */\n    conductUp(node) {\n        const parentNode = node.getParentNode();\n        if (parentNode) {\n            if (!isCheckDisabled(parentNode)) {\n                if (parentNode.children.every(child => isCheckDisabled(child) || (!child.isHalfChecked && child.isChecked))) {\n                    parentNode.isChecked = true;\n                    parentNode.isHalfChecked = false;\n                }\n                else if (parentNode.children.some(child => child.isHalfChecked || child.isChecked)) {\n                    parentNode.isChecked = false;\n                    parentNode.isHalfChecked = true;\n                }\n                else {\n                    parentNode.isChecked = false;\n                    parentNode.isHalfChecked = false;\n                }\n            }\n            this.setCheckedNodeList(parentNode);\n            this.setHalfCheckedNodeList(parentNode);\n            this.conductUp(parentNode);\n        }\n    }\n    /**\n     * reset child check state\n     */\n    conductDown(node, value) {\n        if (!isCheckDisabled(node)) {\n            node.isChecked = value;\n            node.isHalfChecked = false;\n            this.setCheckedNodeList(node);\n            this.setHalfCheckedNodeList(node);\n            node.children.forEach(n => {\n                this.conductDown(n, value);\n            });\n        }\n    }\n    /**\n     * flush after delete node\n     */\n    afterRemove(nodes) {\n        // to reset selectedNodeList & expandedNodeList\n        const loopNode = (node) => {\n            // remove selected node\n            this.selectedNodeList = this.selectedNodeList.filter(n => n.key !== node.key);\n            // remove expanded node\n            this.expandedNodeList = this.expandedNodeList.filter(n => n.key !== node.key);\n            // remove checked node\n            this.checkedNodeList = this.checkedNodeList.filter(n => n.key !== node.key);\n            if (node.children) {\n                node.children.forEach(child => {\n                    loopNode(child);\n                });\n            }\n        };\n        nodes.forEach(n => {\n            loopNode(n);\n        });\n        this.refreshCheckState(this.isCheckStrictly);\n    }\n    /**\n     * drag event\n     */\n    refreshDragNode(node) {\n        if (node.children.length === 0) {\n            // until root\n            this.conductUp(node);\n        }\n        else {\n            node.children.forEach(child => {\n                this.refreshDragNode(child);\n            });\n        }\n    }\n    // reset node level\n    resetNodeLevel(node) {\n        const parentNode = node.getParentNode();\n        if (parentNode) {\n            node.level = parentNode.level + 1;\n        }\n        else {\n            node.level = 0;\n        }\n        for (const child of node.children) {\n            this.resetNodeLevel(child);\n        }\n    }\n    calcDropPosition(event) {\n        const { clientY } = event;\n        // to fix firefox undefined\n        const { top, bottom, height } = event.target.getBoundingClientRect();\n        const des = Math.max(height * this.DRAG_SIDE_RANGE, this.DRAG_MIN_GAP);\n        if (clientY <= top + des) {\n            return -1;\n        }\n        else if (clientY >= bottom - des) {\n            return 1;\n        }\n        return 0;\n    }\n    /**\n     * drop\n     * 0: inner -1: pre 1: next\n     */\n    dropAndApply(targetNode, dragPos = -1) {\n        if (!targetNode || dragPos > 1) {\n            return;\n        }\n        const treeService = targetNode.treeService;\n        const targetParent = targetNode.getParentNode();\n        const isSelectedRootNode = this.selectedNode.getParentNode();\n        // remove the dragNode\n        if (isSelectedRootNode) {\n            isSelectedRootNode.children = isSelectedRootNode.children.filter(n => n.key !== this.selectedNode.key);\n        }\n        else {\n            this.rootNodes = this.rootNodes.filter(n => n.key !== this.selectedNode.key);\n        }\n        switch (dragPos) {\n            case 0:\n                targetNode.addChildren([this.selectedNode]);\n                this.resetNodeLevel(targetNode);\n                break;\n            case -1:\n            case 1:\n                const tIndex = dragPos === 1 ? 1 : 0;\n                if (targetParent) {\n                    targetParent.addChildren([this.selectedNode], targetParent.children.indexOf(targetNode) + tIndex);\n                    const parentNode = this.selectedNode.getParentNode();\n                    if (parentNode) {\n                        this.resetNodeLevel(parentNode);\n                    }\n                }\n                else {\n                    const targetIndex = this.rootNodes.indexOf(targetNode) + tIndex;\n                    // Insert root node.\n                    this.rootNodes.splice(targetIndex, 0, this.selectedNode);\n                    this.rootNodes[targetIndex].parentNode = null;\n                    this.resetNodeLevel(this.rootNodes[targetIndex]);\n                }\n                break;\n        }\n        // flush all nodes\n        this.rootNodes.forEach(child => {\n            if (!child.treeService) {\n                child.service = treeService;\n            }\n            this.refreshDragNode(child);\n        });\n    }\n    /**\n     * emit Structure\n     * eventName\n     * node\n     * event: MouseEvent / DragEvent\n     * dragNode\n     */\n    formatEvent(eventName, node, event) {\n        const emitStructure = {\n            eventName,\n            node,\n            event\n        };\n        switch (eventName) {\n            case 'dragstart':\n            case 'dragenter':\n            case 'dragover':\n            case 'dragleave':\n            case 'drop':\n            case 'dragend':\n                Object.assign(emitStructure, { dragNode: this.getSelectedNode() });\n                break;\n            case 'click':\n            case 'dblclick':\n                Object.assign(emitStructure, { selectedKeys: this.selectedNodeList });\n                Object.assign(emitStructure, { nodes: this.selectedNodeList });\n                Object.assign(emitStructure, { keys: this.selectedNodeList.map(n => n.key) });\n                break;\n            case 'check':\n                const checkedNodeList = this.getCheckedNodeList();\n                Object.assign(emitStructure, { checkedKeys: checkedNodeList });\n                Object.assign(emitStructure, { nodes: checkedNodeList });\n                Object.assign(emitStructure, { keys: checkedNodeList.map(n => n.key) });\n                break;\n            case 'search':\n                Object.assign(emitStructure, { matchedKeys: this.getMatchedNodeList() });\n                Object.assign(emitStructure, { nodes: this.getMatchedNodeList() });\n                Object.assign(emitStructure, { keys: this.getMatchedNodeList().map(n => n.key) });\n                break;\n            case 'expand':\n                Object.assign(emitStructure, { nodes: this.expandedNodeList });\n                Object.assign(emitStructure, { keys: this.expandedNodeList.map(n => n.key) });\n                break;\n        }\n        return emitStructure;\n    }\n    /**\n     * New functions for flatten nodes\n     */\n    getIndexOfArray(list, key) {\n        return list.findIndex(v => v.key === key);\n    }\n    /**\n     * Render by nzCheckedKeys\n     * When keys equals null, just render with checkStrictly\n     *\n     * @param keys\n     * @param checkStrictly\n     */\n    conductCheck(keys, checkStrictly) {\n        this.checkedNodeList = [];\n        this.halfCheckedNodeList = [];\n        const calc = (nodes) => {\n            nodes.forEach(node => {\n                if (keys === null) {\n                    // render tree if no default checked keys found\n                    node.isChecked = !!node.origin.checked;\n                }\n                else {\n                    if (isInArray(node.key, keys || [])) {\n                        node.isChecked = true;\n                        node.isHalfChecked = false;\n                    }\n                    else {\n                        node.isChecked = false;\n                        node.isHalfChecked = false;\n                    }\n                }\n                if (node.children.length > 0) {\n                    calc(node.children);\n                }\n            });\n        };\n        calc(this.rootNodes);\n        this.refreshCheckState(checkStrictly);\n    }\n    conductExpandedKeys(keys = []) {\n        const expandedKeySet = new Set(keys === true ? [] : keys);\n        this.expandedNodeList = [];\n        const calc = (nodes) => {\n            nodes.forEach(node => {\n                node.setExpanded(keys === true || expandedKeySet.has(node.key) || node.isExpanded === true);\n                if (node.isExpanded) {\n                    this.setExpandedNodeList(node);\n                }\n                if (node.children.length > 0) {\n                    calc(node.children);\n                }\n            });\n        };\n        calc(this.rootNodes);\n    }\n    conductSelectedKeys(keys, isMulti) {\n        this.selectedNodeList.forEach(node => (node.isSelected = false));\n        this.selectedNodeList = [];\n        const calc = (nodes) => nodes.every(node => {\n            if (isInArray(node.key, keys)) {\n                node.isSelected = true;\n                this.setSelectedNodeList(node);\n                if (!isMulti) {\n                    // if not support multi select\n                    return false;\n                }\n            }\n            else {\n                node.isSelected = false;\n            }\n            if (node.children.length > 0) {\n                // Recursion\n                return calc(node.children);\n            }\n            return true;\n        });\n        calc(this.rootNodes);\n    }\n    /**\n     * Expand parent nodes by child node\n     *\n     * @param node\n     */\n    expandNodeAllParentBySearch(node) {\n        const calc = (n) => {\n            if (n) {\n                n.canHide = false;\n                n.setExpanded(true);\n                this.setExpandedNodeList(n);\n                if (n.getParentNode()) {\n                    return calc(n.getParentNode());\n                }\n            }\n        };\n        calc(node.getParentNode());\n    }\n}\nNzTreeBaseService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.2\", ngImport: i0, type: NzTreeBaseService, deps: [], target: i0.ɵɵFactoryTarget.Injectable });\nNzTreeBaseService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.2\", ngImport: i0, type: NzTreeBaseService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.2\", ngImport: i0, type: NzTreeBaseService, decorators: [{\n            type: Injectable\n        }] });\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nconst NzTreeHigherOrderServiceToken = new InjectionToken('NzTreeHigherOrder');\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nclass NzTreeBase {\n    constructor(nzTreeService) {\n        this.nzTreeService = nzTreeService;\n    }\n    /**\n     * Coerces a value({@link any[]}) to a TreeNodes({@link NzTreeNode[]})\n     */\n    coerceTreeNodes(value) {\n        let nodes = [];\n        if (!this.nzTreeService.isArrayOfNzTreeNode(value)) {\n            // has not been new NzTreeNode\n            nodes = value.map(item => new NzTreeNode(item, null, this.nzTreeService));\n        }\n        else {\n            nodes = value.map((item) => {\n                item.service = this.nzTreeService;\n                return item;\n            });\n        }\n        return nodes;\n    }\n    /**\n     * Get all nodes({@link NzTreeNode})\n     */\n    getTreeNodes() {\n        return this.nzTreeService.rootNodes;\n    }\n    /**\n     * Get {@link NzTreeNode} with key\n     */\n    getTreeNodeByKey(key) {\n        // flat tree nodes\n        const nodes = [];\n        const getNode = (node) => {\n            nodes.push(node);\n            node.getChildren().forEach(n => {\n                getNode(n);\n            });\n        };\n        this.getTreeNodes().forEach(n => {\n            getNode(n);\n        });\n        return nodes.find(n => n.key === key) || null;\n    }\n    /**\n     * Get checked nodes(merged)\n     */\n    getCheckedNodeList() {\n        return this.nzTreeService.getCheckedNodeList();\n    }\n    /**\n     * Get selected nodes\n     */\n    getSelectedNodeList() {\n        return this.nzTreeService.getSelectedNodeList();\n    }\n    /**\n     * Get half checked nodes\n     */\n    getHalfCheckedNodeList() {\n        return this.nzTreeService.getHalfCheckedNodeList();\n    }\n    /**\n     * Get expanded nodes\n     */\n    getExpandedNodeList() {\n        return this.nzTreeService.getExpandedNodeList();\n    }\n    /**\n     * Get matched nodes(if nzSearchValue is not null)\n     */\n    getMatchedNodeList() {\n        return this.nzTreeService.getMatchedNodeList();\n    }\n}\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NzTreeBase, NzTreeBaseService, NzTreeHigherOrderServiceToken, NzTreeNode, flattenTreeData, getKey, getPosition, isCheckDisabled, isInArray };\n"]},"metadata":{},"sourceType":"module"}