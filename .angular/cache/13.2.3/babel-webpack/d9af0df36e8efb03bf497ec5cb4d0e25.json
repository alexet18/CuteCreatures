{"ast":null,"code":"import * as i1$2 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\nimport * as i1$1 from '@angular/cdk/overlay';\nimport { OverlayConfig, ConnectionPositionPair, OverlayModule } from '@angular/cdk/overlay';\nimport * as i4 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Component, ChangeDetectionStrategy, ViewEncapsulation, Input, EventEmitter, Optional, Output, forwardRef, Directive, Inject, TemplateRef, Host, ContentChildren, ViewChildren, ViewChild, NgModule } from '@angular/core';\nimport { NG_VALUE_ACCESSOR, FormsModule } from '@angular/forms';\nimport * as i2$1 from 'ng-zorro-antd/core/no-animation';\nimport { NzNoAnimationModule } from 'ng-zorro-antd/core/no-animation';\nimport * as i1 from 'ng-zorro-antd/core/outlet';\nimport { NzOutletModule } from 'ng-zorro-antd/core/outlet';\nimport * as i2 from 'ng-zorro-antd/input';\nimport { NzInputModule } from 'ng-zorro-antd/input';\nimport { __decorate } from 'tslib';\nimport { Subject, fromEvent, Subscription, defer, merge } from 'rxjs';\nimport { filter, takeUntil, tap, delay, take, switchMap } from 'rxjs/operators';\nimport { scrollIntoView, InputBoolean } from 'ng-zorro-antd/core/util';\nimport { UP_ARROW, DOWN_ARROW, ESCAPE, TAB, ENTER } from '@angular/cdk/keycodes';\nimport { TemplatePortal } from '@angular/cdk/portal';\nimport { slideMotion } from 'ng-zorro-antd/core/animation';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nfunction NzAutocompleteOptgroupComponent_ng_container_1_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementContainerStart(0);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementContainerEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate(ctx_r0.nzLabel);\n  }\n}\n\nconst _c0 = [[[\"nz-auto-option\"]]];\nconst _c1 = [\"nz-auto-option\"];\nconst _c2 = [\"*\"];\nconst _c3 = [\"panel\"];\nconst _c4 = [\"content\"];\n\nfunction NzAutocompleteComponent_ng_template_0_4_ng_template_0_Template(rf, ctx) {}\n\nfunction NzAutocompleteComponent_ng_template_0_4_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, NzAutocompleteComponent_ng_template_0_4_ng_template_0_Template, 0, 0, \"ng-template\");\n  }\n}\n\nfunction NzAutocompleteComponent_ng_template_0_ng_template_5_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵprojection(0);\n  }\n}\n\nfunction NzAutocompleteComponent_ng_template_0_ng_template_7_nz_auto_option_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelementStart(0, \"nz-auto-option\", 8);\n    i0.ɵɵtext(1);\n    i0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const option_r9 = ctx.$implicit;\n    i0.ɵɵproperty(\"nzValue\", option_r9)(\"nzLabel\", option_r9 && option_r9.label ? option_r9.label : option_r9);\n    i0.ɵɵadvance(1);\n    i0.ɵɵtextInterpolate1(\" \", option_r9 && option_r9.label ? option_r9.label : option_r9, \" \");\n  }\n}\n\nfunction NzAutocompleteComponent_ng_template_0_ng_template_7_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵtemplate(0, NzAutocompleteComponent_ng_template_0_ng_template_7_nz_auto_option_0_Template, 2, 3, \"nz-auto-option\", 7);\n  }\n\n  if (rf & 2) {\n    const ctx_r6 = i0.ɵɵnextContext(2);\n    i0.ɵɵproperty(\"ngForOf\", ctx_r6.nzDataSource);\n  }\n}\n\nfunction NzAutocompleteComponent_ng_template_0_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r11 = i0.ɵɵgetCurrentView();\n\n    i0.ɵɵelementStart(0, \"div\", 0, 1);\n    i0.ɵɵlistener(\"@slideMotion.done\", function NzAutocompleteComponent_ng_template_0_Template_div_animation_slideMotion_done_0_listener($event) {\n      i0.ɵɵrestoreView(_r11);\n      const ctx_r10 = i0.ɵɵnextContext();\n      return ctx_r10.onAnimationEvent($event);\n    });\n    i0.ɵɵelementStart(2, \"div\", 2);\n    i0.ɵɵelementStart(3, \"div\", 3);\n    i0.ɵɵtemplate(4, NzAutocompleteComponent_ng_template_0_4_Template, 1, 0, null, 4);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementEnd();\n    i0.ɵɵtemplate(5, NzAutocompleteComponent_ng_template_0_ng_template_5_Template, 1, 0, \"ng-template\", null, 5, i0.ɵɵtemplateRefExtractor);\n    i0.ɵɵtemplate(7, NzAutocompleteComponent_ng_template_0_ng_template_7_Template, 1, 1, \"ng-template\", null, 6, i0.ɵɵtemplateRefExtractor);\n  }\n\n  if (rf & 2) {\n    const _r3 = i0.ɵɵreference(6);\n\n    const _r5 = i0.ɵɵreference(8);\n\n    const ctx_r0 = i0.ɵɵnextContext();\n    i0.ɵɵclassProp(\"ant-select-dropdown-hidden\", !ctx_r0.showPanel)(\"ant-select-dropdown-rtl\", ctx_r0.dir === \"rtl\");\n    i0.ɵɵproperty(\"ngClass\", ctx_r0.nzOverlayClassName)(\"ngStyle\", ctx_r0.nzOverlayStyle)(\"nzNoAnimation\", ctx_r0.noAnimation == null ? null : ctx_r0.noAnimation.nzNoAnimation)(\"@slideMotion\", undefined)(\"@.disabled\", ctx_r0.noAnimation == null ? null : ctx_r0.noAnimation.nzNoAnimation);\n    i0.ɵɵadvance(4);\n    i0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r0.nzDataSource ? _r5 : _r3);\n  }\n}\n\nlet NzAutocompleteOptgroupComponent = /*#__PURE__*/(() => {\n  class NzAutocompleteOptgroupComponent {\n    constructor() {}\n\n  }\n\n  NzAutocompleteOptgroupComponent.ɵfac = function NzAutocompleteOptgroupComponent_Factory(t) {\n    return new (t || NzAutocompleteOptgroupComponent)();\n  };\n\n  NzAutocompleteOptgroupComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NzAutocompleteOptgroupComponent,\n    selectors: [[\"nz-auto-optgroup\"]],\n    inputs: {\n      nzLabel: \"nzLabel\"\n    },\n    exportAs: [\"nzAutoOptgroup\"],\n    ngContentSelectors: _c1,\n    decls: 3,\n    vars: 1,\n    consts: [[1, \"ant-select-item\", \"ant-select-item-group\"], [4, \"nzStringTemplateOutlet\"]],\n    template: function NzAutocompleteOptgroupComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef(_c0);\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵtemplate(1, NzAutocompleteOptgroupComponent_ng_container_1_Template, 2, 1, \"ng-container\", 1);\n        i0.ɵɵelementEnd();\n        i0.ɵɵprojection(2);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵadvance(1);\n        i0.ɵɵproperty(\"nzStringTemplateOutlet\", ctx.nzLabel);\n      }\n    },\n    directives: [i1.NzStringTemplateOutletDirective],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return NzAutocompleteOptgroupComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nclass NzOptionSelectionChange {\n  constructor(source, isUserInput = false) {\n    this.source = source;\n    this.isUserInput = isUserInput;\n  }\n\n}\n\nlet NzAutocompleteOptionComponent = /*#__PURE__*/(() => {\n  class NzAutocompleteOptionComponent {\n    constructor(ngZone, changeDetectorRef, element, nzAutocompleteOptgroupComponent) {\n      this.ngZone = ngZone;\n      this.changeDetectorRef = changeDetectorRef;\n      this.element = element;\n      this.nzAutocompleteOptgroupComponent = nzAutocompleteOptgroupComponent;\n      this.nzDisabled = false;\n      this.selectionChange = new EventEmitter();\n      this.mouseEntered = new EventEmitter();\n      this.active = false;\n      this.selected = false;\n      this.destroy$ = new Subject();\n    }\n\n    ngOnInit() {\n      this.ngZone.runOutsideAngular(() => {\n        fromEvent(this.element.nativeElement, 'mouseenter').pipe(filter(() => this.mouseEntered.observers.length > 0), takeUntil(this.destroy$)).subscribe(() => {\n          this.ngZone.run(() => this.mouseEntered.emit(this));\n        });\n        fromEvent(this.element.nativeElement, 'mousedown').pipe(takeUntil(this.destroy$)).subscribe(event => event.preventDefault());\n      });\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n    }\n\n    select(emit = true) {\n      this.selected = true;\n      this.changeDetectorRef.markForCheck();\n\n      if (emit) {\n        this.emitSelectionChangeEvent();\n      }\n    }\n\n    deselect() {\n      this.selected = false;\n      this.changeDetectorRef.markForCheck();\n      this.emitSelectionChangeEvent();\n    }\n    /** Git display label */\n\n\n    getLabel() {\n      return this.nzLabel || this.nzValue.toString();\n    }\n    /** Set active (only styles) */\n\n\n    setActiveStyles() {\n      if (!this.active) {\n        this.active = true;\n        this.changeDetectorRef.markForCheck();\n      }\n    }\n    /** Unset active (only styles) */\n\n\n    setInactiveStyles() {\n      if (this.active) {\n        this.active = false;\n        this.changeDetectorRef.markForCheck();\n      }\n    }\n\n    scrollIntoViewIfNeeded() {\n      scrollIntoView(this.element.nativeElement);\n    }\n\n    selectViaInteraction() {\n      if (!this.nzDisabled) {\n        this.selected = !this.selected;\n\n        if (this.selected) {\n          this.setActiveStyles();\n        } else {\n          this.setInactiveStyles();\n        }\n\n        this.emitSelectionChangeEvent(true);\n        this.changeDetectorRef.markForCheck();\n      }\n    }\n\n    emitSelectionChangeEvent(isUserInput = false) {\n      this.selectionChange.emit(new NzOptionSelectionChange(this, isUserInput));\n    }\n\n  }\n\n  NzAutocompleteOptionComponent.ɵfac = function NzAutocompleteOptionComponent_Factory(t) {\n    return new (t || NzAutocompleteOptionComponent)(i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(NzAutocompleteOptgroupComponent, 8));\n  };\n\n  NzAutocompleteOptionComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NzAutocompleteOptionComponent,\n    selectors: [[\"nz-auto-option\"]],\n    hostAttrs: [\"role\", \"menuitem\", 1, \"ant-select-item\", \"ant-select-item-option\"],\n    hostVars: 10,\n    hostBindings: function NzAutocompleteOptionComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function NzAutocompleteOptionComponent_click_HostBindingHandler() {\n          return ctx.selectViaInteraction();\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵattribute(\"aria-selected\", ctx.selected.toString())(\"aria-disabled\", ctx.nzDisabled.toString());\n        i0.ɵɵclassProp(\"ant-select-item-option-grouped\", ctx.nzAutocompleteOptgroupComponent)(\"ant-select-item-option-selected\", ctx.selected)(\"ant-select-item-option-active\", ctx.active)(\"ant-select-item-option-disabled\", ctx.nzDisabled);\n      }\n    },\n    inputs: {\n      nzValue: \"nzValue\",\n      nzLabel: \"nzLabel\",\n      nzDisabled: \"nzDisabled\"\n    },\n    outputs: {\n      selectionChange: \"selectionChange\",\n      mouseEntered: \"mouseEntered\"\n    },\n    exportAs: [\"nzAutoOption\"],\n    ngContentSelectors: _c2,\n    decls: 2,\n    vars: 0,\n    consts: [[1, \"ant-select-item-option-content\"]],\n    template: function NzAutocompleteOptionComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([InputBoolean()], NzAutocompleteOptionComponent.prototype, \"nzDisabled\", void 0);\n\n  return NzAutocompleteOptionComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nconst NZ_AUTOCOMPLETE_VALUE_ACCESSOR = {\n  provide: NG_VALUE_ACCESSOR,\n  useExisting: forwardRef(() => NzAutocompleteTriggerDirective),\n  multi: true\n};\n\nfunction getNzAutocompleteMissingPanelError() {\n  return Error('Attempting to open an undefined instance of `nz-autocomplete`. ' + 'Make sure that the id passed to the `nzAutocomplete` is correct and that ' + \"you're attempting to open it after the ngAfterContentInit hook.\");\n}\n\nlet NzAutocompleteTriggerDirective = /*#__PURE__*/(() => {\n  class NzAutocompleteTriggerDirective {\n    constructor(elementRef, overlay, viewContainerRef, nzInputGroupWhitSuffixOrPrefixDirective, document) {\n      this.elementRef = elementRef;\n      this.overlay = overlay;\n      this.viewContainerRef = viewContainerRef;\n      this.nzInputGroupWhitSuffixOrPrefixDirective = nzInputGroupWhitSuffixOrPrefixDirective;\n      this.document = document;\n\n      this.onChange = () => {};\n\n      this.onTouched = () => {};\n\n      this.panelOpen = false;\n      this.destroy$ = new Subject();\n      this.overlayRef = null;\n      this.portal = null;\n      this.previousValue = null;\n    }\n    /** Current active option */\n\n\n    get activeOption() {\n      if (this.nzAutocomplete && this.nzAutocomplete.options.length) {\n        return this.nzAutocomplete.activeItem;\n      } else {\n        return null;\n      }\n    }\n\n    ngAfterViewInit() {\n      if (this.nzAutocomplete) {\n        this.nzAutocomplete.animationStateChange.pipe(takeUntil(this.destroy$)).subscribe(event => {\n          if (event.toState === 'void') {\n            if (this.overlayRef) {\n              this.overlayRef.dispose();\n              this.overlayRef = null;\n            }\n          }\n        });\n      }\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n      this.destroyPanel();\n    }\n\n    writeValue(value) {\n      Promise.resolve(null).then(() => this.setTriggerValue(value));\n    }\n\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n\n    setDisabledState(isDisabled) {\n      const element = this.elementRef.nativeElement;\n      element.disabled = isDisabled;\n      this.closePanel();\n    }\n\n    openPanel() {\n      this.previousValue = this.elementRef.nativeElement.value;\n      this.attachOverlay();\n      this.updateStatus();\n    }\n\n    closePanel() {\n      if (this.panelOpen) {\n        this.nzAutocomplete.isOpen = this.panelOpen = false;\n\n        if (this.overlayRef && this.overlayRef.hasAttached()) {\n          this.overlayRef.detach();\n          this.selectionChangeSubscription.unsubscribe();\n          this.overlayOutsideClickSubscription.unsubscribe();\n          this.optionsChangeSubscription.unsubscribe();\n          this.portal = null;\n        }\n      }\n    }\n\n    handleKeydown(event) {\n      const keyCode = event.keyCode;\n      const isArrowKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW;\n\n      if (keyCode === ESCAPE) {\n        event.preventDefault();\n      }\n\n      if (this.panelOpen && (keyCode === ESCAPE || keyCode === TAB)) {\n        // Reset value when tab / ESC close\n        if (this.activeOption && this.activeOption.getLabel() !== this.previousValue) {\n          this.setTriggerValue(this.previousValue);\n        }\n\n        this.closePanel();\n      } else if (this.panelOpen && keyCode === ENTER) {\n        if (this.nzAutocomplete.showPanel) {\n          event.preventDefault();\n\n          if (this.activeOption) {\n            this.activeOption.selectViaInteraction();\n          } else {\n            this.closePanel();\n          }\n        }\n      } else if (this.panelOpen && isArrowKey && this.nzAutocomplete.showPanel) {\n        event.stopPropagation();\n        event.preventDefault();\n\n        if (keyCode === UP_ARROW) {\n          this.nzAutocomplete.setPreviousItemActive();\n        } else {\n          this.nzAutocomplete.setNextItemActive();\n        }\n\n        if (this.activeOption) {\n          this.activeOption.scrollIntoViewIfNeeded();\n        }\n\n        this.doBackfill();\n      }\n    }\n\n    handleInput(event) {\n      const target = event.target;\n      const document = this.document;\n      let value = target.value;\n\n      if (target.type === 'number') {\n        value = value === '' ? null : parseFloat(value);\n      }\n\n      if (this.previousValue !== value) {\n        this.previousValue = value;\n        this.onChange(value);\n\n        if (this.canOpen() && document.activeElement === event.target) {\n          this.openPanel();\n        }\n      }\n    }\n\n    handleFocus() {\n      if (this.canOpen()) {\n        this.openPanel();\n      }\n    }\n\n    handleBlur() {\n      this.onTouched();\n    }\n    /**\n     * Subscription data source changes event\n     */\n\n\n    subscribeOptionsChange() {\n      const optionChanges = this.nzAutocomplete.options.changes.pipe(tap(() => this.positionStrategy.reapplyLastPosition()), delay(0));\n      return optionChanges.subscribe(() => {\n        this.resetActiveItem();\n\n        if (this.panelOpen) {\n          this.overlayRef.updatePosition();\n        }\n      });\n    }\n    /**\n     * Subscription option changes event and set the value\n     */\n\n\n    subscribeSelectionChange() {\n      return this.nzAutocomplete.selectionChange.subscribe(option => {\n        this.setValueAndClose(option);\n      });\n    }\n\n    subscribeOverlayOutsideClick() {\n      return this.overlayRef.outsidePointerEvents().pipe(filter(e => !this.elementRef.nativeElement.contains(e.target))).subscribe(() => {\n        this.closePanel();\n      });\n    }\n\n    attachOverlay() {\n      if (!this.nzAutocomplete) {\n        throw getNzAutocompleteMissingPanelError();\n      }\n\n      if (!this.portal && this.nzAutocomplete.template) {\n        this.portal = new TemplatePortal(this.nzAutocomplete.template, this.viewContainerRef);\n      }\n\n      if (!this.overlayRef) {\n        this.overlayRef = this.overlay.create(this.getOverlayConfig());\n      }\n\n      if (this.overlayRef && !this.overlayRef.hasAttached()) {\n        this.overlayRef.attach(this.portal);\n        this.selectionChangeSubscription = this.subscribeSelectionChange();\n        this.optionsChangeSubscription = this.subscribeOptionsChange();\n        this.overlayOutsideClickSubscription = this.subscribeOverlayOutsideClick();\n        this.overlayRef.detachments().pipe(takeUntil(this.destroy$)).subscribe(() => {\n          this.closePanel();\n        });\n      }\n\n      this.nzAutocomplete.isOpen = this.panelOpen = true;\n    }\n\n    updateStatus() {\n      if (this.overlayRef) {\n        this.overlayRef.updateSize({\n          width: this.nzAutocomplete.nzWidth || this.getHostWidth()\n        });\n      }\n\n      this.nzAutocomplete.setVisibility();\n      this.resetActiveItem();\n\n      if (this.activeOption) {\n        this.activeOption.scrollIntoViewIfNeeded();\n      }\n    }\n\n    destroyPanel() {\n      if (this.overlayRef) {\n        this.closePanel();\n      }\n    }\n\n    getOverlayConfig() {\n      return new OverlayConfig({\n        positionStrategy: this.getOverlayPosition(),\n        disposeOnNavigation: true,\n        scrollStrategy: this.overlay.scrollStrategies.reposition(),\n        // default host element width\n        width: this.nzAutocomplete.nzWidth || this.getHostWidth()\n      });\n    }\n\n    getConnectedElement() {\n      return this.nzInputGroupWhitSuffixOrPrefixDirective ? this.nzInputGroupWhitSuffixOrPrefixDirective.elementRef : this.elementRef;\n    }\n\n    getHostWidth() {\n      return this.getConnectedElement().nativeElement.getBoundingClientRect().width;\n    }\n\n    getOverlayPosition() {\n      const positions = [new ConnectionPositionPair({\n        originX: 'start',\n        originY: 'bottom'\n      }, {\n        overlayX: 'start',\n        overlayY: 'top'\n      }), new ConnectionPositionPair({\n        originX: 'start',\n        originY: 'top'\n      }, {\n        overlayX: 'start',\n        overlayY: 'bottom'\n      })];\n      this.positionStrategy = this.overlay.position().flexibleConnectedTo(this.getConnectedElement()).withFlexibleDimensions(false).withPush(false).withPositions(positions).withTransformOriginOn('.ant-select-dropdown');\n      return this.positionStrategy;\n    }\n\n    resetActiveItem() {\n      const index = this.nzAutocomplete.getOptionIndex(this.previousValue);\n      this.nzAutocomplete.clearSelectedOptions(null, true);\n\n      if (index !== -1) {\n        this.nzAutocomplete.setActiveItem(index);\n        this.nzAutocomplete.activeItem.select(false);\n      } else {\n        this.nzAutocomplete.setActiveItem(this.nzAutocomplete.nzDefaultActiveFirstOption ? 0 : -1);\n      }\n    }\n\n    setValueAndClose(option) {\n      const value = option.nzValue;\n      this.setTriggerValue(option.getLabel());\n      this.onChange(value);\n      this.elementRef.nativeElement.focus();\n      this.closePanel();\n    }\n\n    setTriggerValue(value) {\n      const option = this.nzAutocomplete.getOption(value);\n      const displayValue = option ? option.getLabel() : value;\n      this.elementRef.nativeElement.value = displayValue != null ? displayValue : '';\n\n      if (!this.nzAutocomplete.nzBackfill) {\n        this.previousValue = displayValue;\n      }\n    }\n\n    doBackfill() {\n      if (this.nzAutocomplete.nzBackfill && this.nzAutocomplete.activeItem) {\n        this.setTriggerValue(this.nzAutocomplete.activeItem.getLabel());\n      }\n    }\n\n    canOpen() {\n      const element = this.elementRef.nativeElement;\n      return !element.readOnly && !element.disabled;\n    }\n\n  }\n\n  NzAutocompleteTriggerDirective.ɵfac = function NzAutocompleteTriggerDirective_Factory(t) {\n    return new (t || NzAutocompleteTriggerDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i1$1.Overlay), i0.ɵɵdirectiveInject(i0.ViewContainerRef), i0.ɵɵdirectiveInject(i2.NzInputGroupWhitSuffixOrPrefixDirective, 8), i0.ɵɵdirectiveInject(DOCUMENT, 8));\n  };\n\n  NzAutocompleteTriggerDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NzAutocompleteTriggerDirective,\n    selectors: [[\"input\", \"nzAutocomplete\", \"\"], [\"textarea\", \"nzAutocomplete\", \"\"]],\n    hostAttrs: [\"autocomplete\", \"off\", \"aria-autocomplete\", \"list\"],\n    hostBindings: function NzAutocompleteTriggerDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focusin\", function NzAutocompleteTriggerDirective_focusin_HostBindingHandler() {\n          return ctx.handleFocus();\n        })(\"blur\", function NzAutocompleteTriggerDirective_blur_HostBindingHandler() {\n          return ctx.handleBlur();\n        })(\"input\", function NzAutocompleteTriggerDirective_input_HostBindingHandler($event) {\n          return ctx.handleInput($event);\n        })(\"keydown\", function NzAutocompleteTriggerDirective_keydown_HostBindingHandler($event) {\n          return ctx.handleKeydown($event);\n        });\n      }\n    },\n    inputs: {\n      nzAutocomplete: \"nzAutocomplete\"\n    },\n    exportAs: [\"nzAutocompleteTrigger\"],\n    features: [i0.ɵɵProvidersFeature([NZ_AUTOCOMPLETE_VALUE_ACCESSOR])]\n  });\n  return NzAutocompleteTriggerDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NzAutocompleteComponent = /*#__PURE__*/(() => {\n  class NzAutocompleteComponent {\n    constructor(changeDetectorRef, ngZone, directionality, noAnimation) {\n      this.changeDetectorRef = changeDetectorRef;\n      this.ngZone = ngZone;\n      this.directionality = directionality;\n      this.noAnimation = noAnimation;\n      this.nzOverlayClassName = '';\n      this.nzOverlayStyle = {};\n      this.nzDefaultActiveFirstOption = true;\n      this.nzBackfill = false;\n\n      this.compareWith = (o1, o2) => o1 === o2;\n\n      this.selectionChange = new EventEmitter();\n      this.showPanel = true;\n      this.isOpen = false;\n      this.activeItem = null;\n      this.dir = 'ltr';\n      this.destroy$ = new Subject();\n      this.animationStateChange = new EventEmitter();\n      this.activeItemIndex = -1;\n      this.selectionChangeSubscription = Subscription.EMPTY;\n      this.optionMouseEnterSubscription = Subscription.EMPTY;\n      this.dataSourceChangeSubscription = Subscription.EMPTY;\n      /** Options changes listener */\n\n      this.optionSelectionChanges = defer(() => {\n        if (this.options) {\n          return merge(...this.options.map(option => option.selectionChange));\n        }\n\n        return this.ngZone.onStable.asObservable().pipe(take(1), switchMap(() => this.optionSelectionChanges));\n      });\n      this.optionMouseEnter = defer(() => {\n        if (this.options) {\n          return merge(...this.options.map(option => option.mouseEntered));\n        }\n\n        return this.ngZone.onStable.asObservable().pipe(take(1), switchMap(() => this.optionMouseEnter));\n      });\n    }\n    /**\n     * Options accessor, its source may be content or dataSource\n     */\n\n\n    get options() {\n      // first dataSource\n      if (this.nzDataSource) {\n        return this.fromDataSourceOptions;\n      } else {\n        return this.fromContentOptions;\n      }\n    }\n\n    ngOnInit() {\n      var _a;\n\n      (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n        this.changeDetectorRef.detectChanges();\n      });\n      this.dir = this.directionality.value;\n    }\n\n    onAnimationEvent(event) {\n      this.animationStateChange.emit(event);\n    }\n\n    ngAfterContentInit() {\n      if (!this.nzDataSource) {\n        this.optionsInit();\n      }\n    }\n\n    ngAfterViewInit() {\n      if (this.nzDataSource) {\n        this.optionsInit();\n      }\n    }\n\n    ngOnDestroy() {\n      this.dataSourceChangeSubscription.unsubscribe();\n      this.selectionChangeSubscription.unsubscribe();\n      this.optionMouseEnterSubscription.unsubscribe(); // Caretaker note: we have to set these subscriptions to `null` since these will be closed subscriptions, but they\n      // still keep references to destinations (which are `SafeSubscriber`s). Destinations keep referencing `next` functions,\n      // which we pass, for instance, to `this.optionSelectionChanges.subscribe(...)`.\n\n      this.dataSourceChangeSubscription = this.selectionChangeSubscription = this.optionMouseEnterSubscription = null;\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n    setVisibility() {\n      this.showPanel = !!this.options.length;\n      this.changeDetectorRef.markForCheck();\n    }\n\n    setActiveItem(index) {\n      const activeItem = this.options.get(index);\n\n      if (activeItem && !activeItem.active) {\n        this.activeItem = activeItem;\n        this.activeItemIndex = index;\n        this.clearSelectedOptions(this.activeItem);\n        this.activeItem.setActiveStyles();\n      } else {\n        this.activeItem = null;\n        this.activeItemIndex = -1;\n        this.clearSelectedOptions();\n      }\n\n      this.changeDetectorRef.markForCheck();\n    }\n\n    setNextItemActive() {\n      const nextIndex = this.activeItemIndex + 1 <= this.options.length - 1 ? this.activeItemIndex + 1 : 0;\n      this.setActiveItem(nextIndex);\n    }\n\n    setPreviousItemActive() {\n      const previousIndex = this.activeItemIndex - 1 < 0 ? this.options.length - 1 : this.activeItemIndex - 1;\n      this.setActiveItem(previousIndex);\n    }\n\n    getOptionIndex(value) {\n      return this.options.reduce((result, current, index) => result === -1 ? this.compareWith(value, current.nzValue) ? index : -1 : result, -1);\n    }\n\n    getOption(value) {\n      return this.options.find(item => this.compareWith(value, item.nzValue)) || null;\n    }\n\n    optionsInit() {\n      this.setVisibility();\n      this.subscribeOptionChanges();\n      const changes = this.nzDataSource ? this.fromDataSourceOptions.changes : this.fromContentOptions.changes; // async\n\n      this.dataSourceChangeSubscription = changes.subscribe(e => {\n        if (!e.dirty && this.isOpen) {\n          setTimeout(() => this.setVisibility());\n        }\n\n        this.subscribeOptionChanges();\n      });\n    }\n    /**\n     * Clear the status of options\n     */\n\n\n    clearSelectedOptions(skip, deselect = false) {\n      this.options.forEach(option => {\n        if (option !== skip) {\n          if (deselect) {\n            option.deselect();\n          }\n\n          option.setInactiveStyles();\n        }\n      });\n    }\n\n    subscribeOptionChanges() {\n      this.selectionChangeSubscription.unsubscribe();\n      this.selectionChangeSubscription = this.optionSelectionChanges.pipe(filter(event => event.isUserInput)).subscribe(event => {\n        event.source.select();\n        event.source.setActiveStyles();\n        this.activeItem = event.source;\n        this.activeItemIndex = this.getOptionIndex(this.activeItem.nzValue);\n        this.clearSelectedOptions(event.source, true);\n        this.selectionChange.emit(event.source);\n      });\n      this.optionMouseEnterSubscription.unsubscribe();\n      this.optionMouseEnterSubscription = this.optionMouseEnter.subscribe(event => {\n        event.setActiveStyles();\n        this.activeItem = event;\n        this.activeItemIndex = this.getOptionIndex(this.activeItem.nzValue);\n        this.clearSelectedOptions(event);\n      });\n    }\n\n  }\n\n  NzAutocompleteComponent.ɵfac = function NzAutocompleteComponent_Factory(t) {\n    return new (t || NzAutocompleteComponent)(i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i1$2.Directionality, 8), i0.ɵɵdirectiveInject(i2$1.NzNoAnimationDirective, 9));\n  };\n\n  NzAutocompleteComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NzAutocompleteComponent,\n    selectors: [[\"nz-autocomplete\"]],\n    contentQueries: function NzAutocompleteComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, NzAutocompleteOptionComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fromContentOptions = _t);\n      }\n    },\n    viewQuery: function NzAutocompleteComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(TemplateRef, 5);\n        i0.ɵɵviewQuery(_c3, 5);\n        i0.ɵɵviewQuery(_c4, 5);\n        i0.ɵɵviewQuery(NzAutocompleteOptionComponent, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.template = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.panel = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.content = _t.first);\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fromDataSourceOptions = _t);\n      }\n    },\n    inputs: {\n      nzWidth: \"nzWidth\",\n      nzOverlayClassName: \"nzOverlayClassName\",\n      nzOverlayStyle: \"nzOverlayStyle\",\n      nzDefaultActiveFirstOption: \"nzDefaultActiveFirstOption\",\n      nzBackfill: \"nzBackfill\",\n      compareWith: \"compareWith\",\n      nzDataSource: \"nzDataSource\"\n    },\n    outputs: {\n      selectionChange: \"selectionChange\"\n    },\n    exportAs: [\"nzAutocomplete\"],\n    ngContentSelectors: _c2,\n    decls: 1,\n    vars: 0,\n    consts: [[1, \"ant-select-dropdown\", \"ant-select-dropdown-placement-bottomLeft\", 3, \"ngClass\", \"ngStyle\", \"nzNoAnimation\"], [\"panel\", \"\"], [2, \"max-height\", \"256px\", \"overflow-y\", \"auto\", \"overflow-anchor\", \"none\"], [2, \"display\", \"flex\", \"flex-direction\", \"column\"], [4, \"ngTemplateOutlet\"], [\"contentTemplate\", \"\"], [\"optionsTemplate\", \"\"], [3, \"nzValue\", \"nzLabel\", 4, \"ngFor\", \"ngForOf\"], [3, \"nzValue\", \"nzLabel\"]],\n    template: function NzAutocompleteComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵtemplate(0, NzAutocompleteComponent_ng_template_0_Template, 9, 10, \"ng-template\");\n      }\n    },\n    directives: [NzAutocompleteOptionComponent, i4.NgClass, i4.NgStyle, i2$1.NzNoAnimationDirective, i4.NgTemplateOutlet, i4.NgForOf],\n    encapsulation: 2,\n    data: {\n      animation: [slideMotion]\n    },\n    changeDetection: 0\n  });\n\n  __decorate([InputBoolean()], NzAutocompleteComponent.prototype, \"nzDefaultActiveFirstOption\", void 0);\n\n  __decorate([InputBoolean()], NzAutocompleteComponent.prototype, \"nzBackfill\", void 0);\n\n  return NzAutocompleteComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzAutocompleteModule = /*#__PURE__*/(() => {\n  class NzAutocompleteModule {}\n\n  NzAutocompleteModule.ɵfac = function NzAutocompleteModule_Factory(t) {\n    return new (t || NzAutocompleteModule)();\n  };\n\n  NzAutocompleteModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NzAutocompleteModule\n  });\n  NzAutocompleteModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[BidiModule, CommonModule, OverlayModule, FormsModule, NzOutletModule, NzNoAnimationModule, NzInputModule]]\n  });\n  return NzAutocompleteModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NZ_AUTOCOMPLETE_VALUE_ACCESSOR, NzAutocompleteComponent, NzAutocompleteModule, NzAutocompleteOptgroupComponent, NzAutocompleteOptionComponent, NzAutocompleteTriggerDirective, NzOptionSelectionChange, getNzAutocompleteMissingPanelError }; //# sourceMappingURL=ng-zorro-antd-auto-complete.mjs.map","map":null,"metadata":{},"sourceType":"module"}