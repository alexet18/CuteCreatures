{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, InjectionToken } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nclass NzTreeNode {\n  /**\n   * Init nzTreeNode\n   *\n   * @param option: user's input\n   * @param parent\n   * @param service: base nzTreeService\n   */\n  constructor(option, parent = null, service = null) {\n    this._title = '';\n    this.level = 0; // Parent Node\n\n    this.parentNode = null;\n    this._icon = '';\n    this._children = [];\n    this._isLeaf = false;\n    this._isChecked = false;\n    this._isSelectable = false;\n    this._isDisabled = false;\n    this._isDisableCheckbox = false;\n    this._isExpanded = false;\n    this._isHalfChecked = false;\n    this._isSelected = false;\n    this._isLoading = false;\n    this.canHide = false;\n    this.isMatched = false;\n    this.service = null;\n\n    if (option instanceof NzTreeNode) {\n      return option;\n    }\n\n    this.service = service || null;\n    this.origin = option;\n    this.key = option.key;\n    this.parentNode = parent;\n    this._title = option.title || '---';\n    this._icon = option.icon || '';\n    this._isLeaf = option.isLeaf || false;\n    this._children = []; // option params\n\n    this._isChecked = option.checked || false;\n    this._isSelectable = option.disabled || option.selectable !== false;\n    this._isDisabled = option.disabled || false;\n    this._isDisableCheckbox = option.disableCheckbox || false;\n    this._isExpanded = option.isLeaf ? false : option.expanded || false;\n    this._isHalfChecked = false;\n    this._isSelected = !option.disabled && option.selected || false;\n    this._isLoading = false;\n    this.isMatched = false;\n    /**\n     * parent's checked status will affect children while initializing\n     */\n\n    if (parent) {\n      this.level = parent.level + 1;\n    } else {\n      this.level = 0;\n    }\n\n    if (typeof option.children !== 'undefined' && option.children !== null) {\n      option.children.forEach(nodeOptions => {\n        const s = this.treeService;\n\n        if (s && !s.isCheckStrictly && option.checked && !option.disabled && !nodeOptions.disabled && !nodeOptions.disableCheckbox) {\n          nodeOptions.checked = option.checked;\n        }\n\n        this._children.push(new NzTreeNode(nodeOptions, this));\n      });\n    }\n  }\n\n  get treeService() {\n    return this.service || this.parentNode && this.parentNode.treeService;\n  }\n  /**\n   * auto generate\n   * get\n   * set\n   */\n\n\n  get title() {\n    return this._title;\n  }\n\n  set title(value) {\n    this._title = value;\n    this.update();\n  }\n\n  get icon() {\n    return this._icon;\n  }\n\n  set icon(value) {\n    this._icon = value;\n    this.update();\n  }\n\n  get children() {\n    return this._children;\n  }\n\n  set children(value) {\n    this._children = value;\n    this.update();\n  }\n\n  get isLeaf() {\n    return this._isLeaf;\n  }\n\n  set isLeaf(value) {\n    this._isLeaf = value;\n    this.update();\n  }\n\n  get isChecked() {\n    return this._isChecked;\n  }\n\n  set isChecked(value) {\n    this._isChecked = value;\n    this.origin.checked = value;\n    this.afterValueChange('isChecked');\n  }\n\n  get isHalfChecked() {\n    return this._isHalfChecked;\n  }\n\n  set isHalfChecked(value) {\n    this._isHalfChecked = value;\n    this.afterValueChange('isHalfChecked');\n  }\n\n  get isSelectable() {\n    return this._isSelectable;\n  }\n\n  set isSelectable(value) {\n    this._isSelectable = value;\n    this.update();\n  }\n\n  get isDisabled() {\n    return this._isDisabled;\n  }\n\n  set isDisabled(value) {\n    this._isDisabled = value;\n    this.update();\n  }\n\n  get isDisableCheckbox() {\n    return this._isDisableCheckbox;\n  }\n\n  set isDisableCheckbox(value) {\n    this._isDisableCheckbox = value;\n    this.update();\n  }\n\n  get isExpanded() {\n    return this._isExpanded;\n  }\n\n  set isExpanded(value) {\n    this._isExpanded = value;\n    this.origin.expanded = value;\n    this.afterValueChange('isExpanded');\n    this.afterValueChange('reRender');\n  }\n\n  get isSelected() {\n    return this._isSelected;\n  }\n\n  set isSelected(value) {\n    this._isSelected = value;\n    this.origin.selected = value;\n    this.afterValueChange('isSelected');\n  }\n\n  get isLoading() {\n    return this._isLoading;\n  }\n\n  set isLoading(value) {\n    this._isLoading = value;\n    this.update();\n  }\n\n  setSyncChecked(checked = false, halfChecked = false) {\n    this.setChecked(checked, halfChecked);\n\n    if (this.treeService && !this.treeService.isCheckStrictly) {\n      this.treeService.conduct(this);\n    }\n  }\n\n  setChecked(checked = false, halfChecked = false) {\n    this.origin.checked = checked;\n    this.isChecked = checked;\n    this.isHalfChecked = halfChecked;\n  }\n\n  setExpanded(value) {\n    this._isExpanded = value;\n    this.origin.expanded = value;\n    this.afterValueChange('isExpanded');\n  }\n\n  getParentNode() {\n    return this.parentNode;\n  }\n\n  getChildren() {\n    return this.children;\n  }\n  /**\n   * Support appending child nodes by position. Leaf node cannot be appended.\n   */\n\n\n  addChildren(children, childPos = -1) {\n    if (!this.isLeaf) {\n      children.forEach(node => {\n        const refreshLevel = n => {\n          n.getChildren().forEach(c => {\n            c.level = c.getParentNode().level + 1; // flush origin\n\n            c.origin.level = c.level;\n            refreshLevel(c);\n          });\n        };\n\n        let child = node;\n\n        if (child instanceof NzTreeNode) {\n          child.parentNode = this;\n        } else {\n          child = new NzTreeNode(node, this);\n        }\n\n        child.level = this.level + 1;\n        child.origin.level = child.level;\n        refreshLevel(child);\n\n        try {\n          childPos === -1 ? this.children.push(child) : this.children.splice(childPos, 0, child); // flush origin\n        } catch (e) {}\n      });\n      this.origin.children = this.getChildren().map(v => v.origin); // remove loading state\n\n      this.isLoading = false;\n    }\n\n    this.afterValueChange('addChildren');\n    this.afterValueChange('reRender');\n  }\n\n  clearChildren() {\n    // refresh checked state\n    this.afterValueChange('clearChildren');\n    this.children = [];\n    this.origin.children = [];\n    this.afterValueChange('reRender');\n  }\n\n  remove() {\n    const parentNode = this.getParentNode();\n\n    if (parentNode) {\n      parentNode.children = parentNode.getChildren().filter(v => v.key !== this.key);\n      parentNode.origin.children = parentNode.origin.children.filter(v => v.key !== this.key);\n      this.afterValueChange('remove');\n      this.afterValueChange('reRender');\n    }\n  }\n\n  afterValueChange(key) {\n    if (this.treeService) {\n      switch (key) {\n        case 'isChecked':\n          this.treeService.setCheckedNodeList(this);\n          break;\n\n        case 'isHalfChecked':\n          this.treeService.setHalfCheckedNodeList(this);\n          break;\n\n        case 'isExpanded':\n          this.treeService.setExpandedNodeList(this);\n          break;\n\n        case 'isSelected':\n          this.treeService.setNodeActive(this);\n          break;\n\n        case 'clearChildren':\n          this.treeService.afterRemove(this.getChildren());\n          break;\n\n        case 'remove':\n          this.treeService.afterRemove([this]);\n          break;\n\n        case 'reRender':\n          this.treeService.flattenTreeData(this.treeService.rootNodes, this.treeService.getExpandedNodeList().map(v => v.key));\n          break;\n      }\n    }\n\n    this.update();\n  }\n\n  update() {\n    if (this.component) {\n      this.component.markForCheck();\n    }\n  }\n\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nfunction isCheckDisabled(node) {\n  const {\n    isDisabled,\n    isDisableCheckbox\n  } = node;\n  return !!(isDisabled || isDisableCheckbox);\n}\n\nfunction isInArray(needle, haystack) {\n  return haystack.length > 0 && haystack.indexOf(needle) > -1;\n}\n\nfunction getPosition(level, index) {\n  return `${level}-${index}`;\n}\n\nfunction getKey(key, pos) {\n  if (key !== null && key !== undefined) {\n    return key;\n  }\n\n  return pos;\n}\n/**\n * Flat nest tree data into flatten list. This is used for virtual list render.\n *\n * @param treeNodeList Origin data node list\n * @param expandedKeys\n * need expanded keys, provides `true` means all expanded (used in `rc-tree-select`).\n */\n\n\nfunction flattenTreeData(treeNodeList = [], expandedKeys = []) {\n  const expandedKeySet = new Set(expandedKeys === true ? [] : expandedKeys);\n  const flattenList = [];\n\n  function dig(list, parent = null) {\n    return list.map((treeNode, index) => {\n      const pos = getPosition(parent ? parent.pos : '0', index);\n      const mergedKey = getKey(treeNode.key, pos);\n      treeNode.isStart = [...(parent ? parent.isStart : []), index === 0];\n      treeNode.isEnd = [...(parent ? parent.isEnd : []), index === list.length - 1]; // Add FlattenDataNode into list\n      // TODO: only need data here.\n\n      const flattenNode = {\n        parent,\n        pos,\n        children: [],\n        data: treeNode,\n        isStart: [...(parent ? parent.isStart : []), index === 0],\n        isEnd: [...(parent ? parent.isEnd : []), index === list.length - 1]\n      };\n      flattenList.push(flattenNode); // Loop treeNode children\n\n      if (expandedKeys === true || expandedKeySet.has(mergedKey) || treeNode.isExpanded) {\n        flattenNode.children = dig(treeNode.children || [], flattenNode);\n      } else {\n        flattenNode.children = [];\n      }\n\n      return flattenNode;\n    });\n  }\n\n  dig(treeNodeList);\n  return flattenList;\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzTreeBaseService = /*#__PURE__*/(() => {\n  class NzTreeBaseService {\n    constructor() {\n      this.DRAG_SIDE_RANGE = 0.25;\n      this.DRAG_MIN_GAP = 2;\n      this.isCheckStrictly = false;\n      this.isMultiple = false;\n      this.rootNodes = [];\n      this.flattenNodes$ = new BehaviorSubject([]);\n      this.selectedNodeList = [];\n      this.expandedNodeList = [];\n      this.checkedNodeList = [];\n      this.halfCheckedNodeList = [];\n      this.matchedNodeList = [];\n    }\n    /**\n     * reset tree nodes will clear default node list\n     */\n\n\n    initTree(nzNodes) {\n      this.rootNodes = nzNodes;\n      this.expandedNodeList = [];\n      this.selectedNodeList = [];\n      this.halfCheckedNodeList = [];\n      this.checkedNodeList = [];\n      this.matchedNodeList = [];\n    }\n\n    flattenTreeData(nzNodes, expandedKeys = []) {\n      this.flattenNodes$.next(flattenTreeData(nzNodes, expandedKeys).map(item => item.data));\n    }\n\n    getSelectedNode() {\n      return this.selectedNode;\n    }\n    /**\n     * get some list\n     */\n\n\n    getSelectedNodeList() {\n      return this.conductNodeState('select');\n    }\n    /**\n     * return checked nodes\n     */\n\n\n    getCheckedNodeList() {\n      return this.conductNodeState('check');\n    }\n\n    getHalfCheckedNodeList() {\n      return this.conductNodeState('halfCheck');\n    }\n    /**\n     * return expanded nodes\n     */\n\n\n    getExpandedNodeList() {\n      return this.conductNodeState('expand');\n    }\n    /**\n     * return search matched nodes\n     */\n\n\n    getMatchedNodeList() {\n      return this.conductNodeState('match');\n    }\n\n    isArrayOfNzTreeNode(value) {\n      return value.every(item => item instanceof NzTreeNode);\n    }\n    /**\n     * set drag node\n     */\n\n\n    setSelectedNode(node) {\n      this.selectedNode = node;\n    }\n    /**\n     * set node selected status\n     */\n\n\n    setNodeActive(node) {\n      if (!this.isMultiple && node.isSelected) {\n        this.selectedNodeList.forEach(n => {\n          if (node.key !== n.key) {\n            // reset other nodes\n            n.isSelected = false;\n          }\n        }); // single mode: remove pre node\n\n        this.selectedNodeList = [];\n      }\n\n      this.setSelectedNodeList(node, this.isMultiple);\n    }\n    /**\n     * add or remove node to selectedNodeList\n     */\n\n\n    setSelectedNodeList(node, isMultiple = false) {\n      const index = this.getIndexOfArray(this.selectedNodeList, node.key);\n\n      if (isMultiple) {\n        if (node.isSelected && index === -1) {\n          this.selectedNodeList.push(node);\n        }\n      } else {\n        if (node.isSelected && index === -1) {\n          this.selectedNodeList = [node];\n        }\n      }\n\n      if (!node.isSelected) {\n        this.selectedNodeList = this.selectedNodeList.filter(n => n.key !== node.key);\n      }\n    }\n    /**\n     * merge checked nodes\n     */\n\n\n    setHalfCheckedNodeList(node) {\n      const index = this.getIndexOfArray(this.halfCheckedNodeList, node.key);\n\n      if (node.isHalfChecked && index === -1) {\n        this.halfCheckedNodeList.push(node);\n      } else if (!node.isHalfChecked && index > -1) {\n        this.halfCheckedNodeList = this.halfCheckedNodeList.filter(n => node.key !== n.key);\n      }\n    }\n\n    setCheckedNodeList(node) {\n      const index = this.getIndexOfArray(this.checkedNodeList, node.key);\n\n      if (node.isChecked && index === -1) {\n        this.checkedNodeList.push(node);\n      } else if (!node.isChecked && index > -1) {\n        this.checkedNodeList = this.checkedNodeList.filter(n => node.key !== n.key);\n      }\n    }\n    /**\n     * conduct checked/selected/expanded keys\n     */\n\n\n    conductNodeState(type = 'check') {\n      let resultNodesList = [];\n\n      switch (type) {\n        case 'select':\n          resultNodesList = this.selectedNodeList;\n          break;\n\n        case 'expand':\n          resultNodesList = this.expandedNodeList;\n          break;\n\n        case 'match':\n          resultNodesList = this.matchedNodeList;\n          break;\n\n        case 'check':\n          resultNodesList = this.checkedNodeList;\n\n          const isIgnore = node => {\n            const parentNode = node.getParentNode();\n\n            if (parentNode) {\n              if (this.checkedNodeList.findIndex(n => n.key === parentNode.key) > -1) {\n                return true;\n              } else {\n                return isIgnore(parentNode);\n              }\n            }\n\n            return false;\n          }; // merge checked\n\n\n          if (!this.isCheckStrictly) {\n            resultNodesList = this.checkedNodeList.filter(n => !isIgnore(n));\n          }\n\n          break;\n\n        case 'halfCheck':\n          if (!this.isCheckStrictly) {\n            resultNodesList = this.halfCheckedNodeList;\n          }\n\n          break;\n      }\n\n      return resultNodesList;\n    }\n    /**\n     * set expanded nodes\n     */\n\n\n    setExpandedNodeList(node) {\n      if (node.isLeaf) {\n        return;\n      }\n\n      const index = this.getIndexOfArray(this.expandedNodeList, node.key);\n\n      if (node.isExpanded && index === -1) {\n        this.expandedNodeList.push(node);\n      } else if (!node.isExpanded && index > -1) {\n        this.expandedNodeList.splice(index, 1);\n      }\n    }\n\n    setMatchedNodeList(node) {\n      const index = this.getIndexOfArray(this.matchedNodeList, node.key);\n\n      if (node.isMatched && index === -1) {\n        this.matchedNodeList.push(node);\n      } else if (!node.isMatched && index > -1) {\n        this.matchedNodeList.splice(index, 1);\n      }\n    }\n    /**\n     * check state\n     *\n     * @param isCheckStrictly\n     */\n\n\n    refreshCheckState(isCheckStrictly = false) {\n      if (isCheckStrictly) {\n        return;\n      }\n\n      this.checkedNodeList.forEach(node => {\n        this.conduct(node, isCheckStrictly);\n      });\n    } // reset other node checked state based current node\n\n\n    conduct(node, isCheckStrictly = false) {\n      const isChecked = node.isChecked;\n\n      if (node && !isCheckStrictly) {\n        this.conductUp(node);\n        this.conductDown(node, isChecked);\n      }\n    }\n    /**\n     * 1、children half checked\n     * 2、children all checked, parent checked\n     * 3、no children checked\n     */\n\n\n    conductUp(node) {\n      const parentNode = node.getParentNode();\n\n      if (parentNode) {\n        if (!isCheckDisabled(parentNode)) {\n          if (parentNode.children.every(child => isCheckDisabled(child) || !child.isHalfChecked && child.isChecked)) {\n            parentNode.isChecked = true;\n            parentNode.isHalfChecked = false;\n          } else if (parentNode.children.some(child => child.isHalfChecked || child.isChecked)) {\n            parentNode.isChecked = false;\n            parentNode.isHalfChecked = true;\n          } else {\n            parentNode.isChecked = false;\n            parentNode.isHalfChecked = false;\n          }\n        }\n\n        this.setCheckedNodeList(parentNode);\n        this.setHalfCheckedNodeList(parentNode);\n        this.conductUp(parentNode);\n      }\n    }\n    /**\n     * reset child check state\n     */\n\n\n    conductDown(node, value) {\n      if (!isCheckDisabled(node)) {\n        node.isChecked = value;\n        node.isHalfChecked = false;\n        this.setCheckedNodeList(node);\n        this.setHalfCheckedNodeList(node);\n        node.children.forEach(n => {\n          this.conductDown(n, value);\n        });\n      }\n    }\n    /**\n     * flush after delete node\n     */\n\n\n    afterRemove(nodes) {\n      // to reset selectedNodeList & expandedNodeList\n      const loopNode = node => {\n        // remove selected node\n        this.selectedNodeList = this.selectedNodeList.filter(n => n.key !== node.key); // remove expanded node\n\n        this.expandedNodeList = this.expandedNodeList.filter(n => n.key !== node.key); // remove checked node\n\n        this.checkedNodeList = this.checkedNodeList.filter(n => n.key !== node.key);\n\n        if (node.children) {\n          node.children.forEach(child => {\n            loopNode(child);\n          });\n        }\n      };\n\n      nodes.forEach(n => {\n        loopNode(n);\n      });\n      this.refreshCheckState(this.isCheckStrictly);\n    }\n    /**\n     * drag event\n     */\n\n\n    refreshDragNode(node) {\n      if (node.children.length === 0) {\n        // until root\n        this.conductUp(node);\n      } else {\n        node.children.forEach(child => {\n          this.refreshDragNode(child);\n        });\n      }\n    } // reset node level\n\n\n    resetNodeLevel(node) {\n      const parentNode = node.getParentNode();\n\n      if (parentNode) {\n        node.level = parentNode.level + 1;\n      } else {\n        node.level = 0;\n      }\n\n      for (const child of node.children) {\n        this.resetNodeLevel(child);\n      }\n    }\n\n    calcDropPosition(event) {\n      const {\n        clientY\n      } = event; // to fix firefox undefined\n\n      const {\n        top,\n        bottom,\n        height\n      } = event.target.getBoundingClientRect();\n      const des = Math.max(height * this.DRAG_SIDE_RANGE, this.DRAG_MIN_GAP);\n\n      if (clientY <= top + des) {\n        return -1;\n      } else if (clientY >= bottom - des) {\n        return 1;\n      }\n\n      return 0;\n    }\n    /**\n     * drop\n     * 0: inner -1: pre 1: next\n     */\n\n\n    dropAndApply(targetNode, dragPos = -1) {\n      if (!targetNode || dragPos > 1) {\n        return;\n      }\n\n      const treeService = targetNode.treeService;\n      const targetParent = targetNode.getParentNode();\n      const isSelectedRootNode = this.selectedNode.getParentNode(); // remove the dragNode\n\n      if (isSelectedRootNode) {\n        isSelectedRootNode.children = isSelectedRootNode.children.filter(n => n.key !== this.selectedNode.key);\n      } else {\n        this.rootNodes = this.rootNodes.filter(n => n.key !== this.selectedNode.key);\n      }\n\n      switch (dragPos) {\n        case 0:\n          targetNode.addChildren([this.selectedNode]);\n          this.resetNodeLevel(targetNode);\n          break;\n\n        case -1:\n        case 1:\n          const tIndex = dragPos === 1 ? 1 : 0;\n\n          if (targetParent) {\n            targetParent.addChildren([this.selectedNode], targetParent.children.indexOf(targetNode) + tIndex);\n            const parentNode = this.selectedNode.getParentNode();\n\n            if (parentNode) {\n              this.resetNodeLevel(parentNode);\n            }\n          } else {\n            const targetIndex = this.rootNodes.indexOf(targetNode) + tIndex; // Insert root node.\n\n            this.rootNodes.splice(targetIndex, 0, this.selectedNode);\n            this.rootNodes[targetIndex].parentNode = null;\n            this.resetNodeLevel(this.rootNodes[targetIndex]);\n          }\n\n          break;\n      } // flush all nodes\n\n\n      this.rootNodes.forEach(child => {\n        if (!child.treeService) {\n          child.service = treeService;\n        }\n\n        this.refreshDragNode(child);\n      });\n    }\n    /**\n     * emit Structure\n     * eventName\n     * node\n     * event: MouseEvent / DragEvent\n     * dragNode\n     */\n\n\n    formatEvent(eventName, node, event) {\n      const emitStructure = {\n        eventName,\n        node,\n        event\n      };\n\n      switch (eventName) {\n        case 'dragstart':\n        case 'dragenter':\n        case 'dragover':\n        case 'dragleave':\n        case 'drop':\n        case 'dragend':\n          Object.assign(emitStructure, {\n            dragNode: this.getSelectedNode()\n          });\n          break;\n\n        case 'click':\n        case 'dblclick':\n          Object.assign(emitStructure, {\n            selectedKeys: this.selectedNodeList\n          });\n          Object.assign(emitStructure, {\n            nodes: this.selectedNodeList\n          });\n          Object.assign(emitStructure, {\n            keys: this.selectedNodeList.map(n => n.key)\n          });\n          break;\n\n        case 'check':\n          const checkedNodeList = this.getCheckedNodeList();\n          Object.assign(emitStructure, {\n            checkedKeys: checkedNodeList\n          });\n          Object.assign(emitStructure, {\n            nodes: checkedNodeList\n          });\n          Object.assign(emitStructure, {\n            keys: checkedNodeList.map(n => n.key)\n          });\n          break;\n\n        case 'search':\n          Object.assign(emitStructure, {\n            matchedKeys: this.getMatchedNodeList()\n          });\n          Object.assign(emitStructure, {\n            nodes: this.getMatchedNodeList()\n          });\n          Object.assign(emitStructure, {\n            keys: this.getMatchedNodeList().map(n => n.key)\n          });\n          break;\n\n        case 'expand':\n          Object.assign(emitStructure, {\n            nodes: this.expandedNodeList\n          });\n          Object.assign(emitStructure, {\n            keys: this.expandedNodeList.map(n => n.key)\n          });\n          break;\n      }\n\n      return emitStructure;\n    }\n    /**\n     * New functions for flatten nodes\n     */\n\n\n    getIndexOfArray(list, key) {\n      return list.findIndex(v => v.key === key);\n    }\n    /**\n     * Render by nzCheckedKeys\n     * When keys equals null, just render with checkStrictly\n     *\n     * @param keys\n     * @param checkStrictly\n     */\n\n\n    conductCheck(keys, checkStrictly) {\n      this.checkedNodeList = [];\n      this.halfCheckedNodeList = [];\n\n      const calc = nodes => {\n        nodes.forEach(node => {\n          if (keys === null) {\n            // render tree if no default checked keys found\n            node.isChecked = !!node.origin.checked;\n          } else {\n            if (isInArray(node.key, keys || [])) {\n              node.isChecked = true;\n              node.isHalfChecked = false;\n            } else {\n              node.isChecked = false;\n              node.isHalfChecked = false;\n            }\n          }\n\n          if (node.children.length > 0) {\n            calc(node.children);\n          }\n        });\n      };\n\n      calc(this.rootNodes);\n      this.refreshCheckState(checkStrictly);\n    }\n\n    conductExpandedKeys(keys = []) {\n      const expandedKeySet = new Set(keys === true ? [] : keys);\n      this.expandedNodeList = [];\n\n      const calc = nodes => {\n        nodes.forEach(node => {\n          node.setExpanded(keys === true || expandedKeySet.has(node.key) || node.isExpanded === true);\n\n          if (node.isExpanded) {\n            this.setExpandedNodeList(node);\n          }\n\n          if (node.children.length > 0) {\n            calc(node.children);\n          }\n        });\n      };\n\n      calc(this.rootNodes);\n    }\n\n    conductSelectedKeys(keys, isMulti) {\n      this.selectedNodeList.forEach(node => node.isSelected = false);\n      this.selectedNodeList = [];\n\n      const calc = nodes => nodes.every(node => {\n        if (isInArray(node.key, keys)) {\n          node.isSelected = true;\n          this.setSelectedNodeList(node);\n\n          if (!isMulti) {\n            // if not support multi select\n            return false;\n          }\n        } else {\n          node.isSelected = false;\n        }\n\n        if (node.children.length > 0) {\n          // Recursion\n          return calc(node.children);\n        }\n\n        return true;\n      });\n\n      calc(this.rootNodes);\n    }\n    /**\n     * Expand parent nodes by child node\n     *\n     * @param node\n     */\n\n\n    expandNodeAllParentBySearch(node) {\n      const calc = n => {\n        if (n) {\n          n.canHide = false;\n          n.setExpanded(true);\n          this.setExpandedNodeList(n);\n\n          if (n.getParentNode()) {\n            return calc(n.getParentNode());\n          }\n        }\n      };\n\n      calc(node.getParentNode());\n    }\n\n  }\n\n  NzTreeBaseService.ɵfac = function NzTreeBaseService_Factory(t) {\n    return new (t || NzTreeBaseService)();\n  };\n\n  NzTreeBaseService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NzTreeBaseService,\n    factory: NzTreeBaseService.ɵfac\n  });\n  return NzTreeBaseService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nconst NzTreeHigherOrderServiceToken = new InjectionToken('NzTreeHigherOrder');\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nclass NzTreeBase {\n  constructor(nzTreeService) {\n    this.nzTreeService = nzTreeService;\n  }\n  /**\n   * Coerces a value({@link any[]}) to a TreeNodes({@link NzTreeNode[]})\n   */\n\n\n  coerceTreeNodes(value) {\n    let nodes = [];\n\n    if (!this.nzTreeService.isArrayOfNzTreeNode(value)) {\n      // has not been new NzTreeNode\n      nodes = value.map(item => new NzTreeNode(item, null, this.nzTreeService));\n    } else {\n      nodes = value.map(item => {\n        item.service = this.nzTreeService;\n        return item;\n      });\n    }\n\n    return nodes;\n  }\n  /**\n   * Get all nodes({@link NzTreeNode})\n   */\n\n\n  getTreeNodes() {\n    return this.nzTreeService.rootNodes;\n  }\n  /**\n   * Get {@link NzTreeNode} with key\n   */\n\n\n  getTreeNodeByKey(key) {\n    // flat tree nodes\n    const nodes = [];\n\n    const getNode = node => {\n      nodes.push(node);\n      node.getChildren().forEach(n => {\n        getNode(n);\n      });\n    };\n\n    this.getTreeNodes().forEach(n => {\n      getNode(n);\n    });\n    return nodes.find(n => n.key === key) || null;\n  }\n  /**\n   * Get checked nodes(merged)\n   */\n\n\n  getCheckedNodeList() {\n    return this.nzTreeService.getCheckedNodeList();\n  }\n  /**\n   * Get selected nodes\n   */\n\n\n  getSelectedNodeList() {\n    return this.nzTreeService.getSelectedNodeList();\n  }\n  /**\n   * Get half checked nodes\n   */\n\n\n  getHalfCheckedNodeList() {\n    return this.nzTreeService.getHalfCheckedNodeList();\n  }\n  /**\n   * Get expanded nodes\n   */\n\n\n  getExpandedNodeList() {\n    return this.nzTreeService.getExpandedNodeList();\n  }\n  /**\n   * Get matched nodes(if nzSearchValue is not null)\n   */\n\n\n  getMatchedNodeList() {\n    return this.nzTreeService.getMatchedNodeList();\n  }\n\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzTreeBase, NzTreeBaseService, NzTreeHigherOrderServiceToken, NzTreeNode, flattenTreeData, getKey, getPosition, isCheckDisabled, isInArray }; //# sourceMappingURL=ng-zorro-antd-core-tree.mjs.map","map":null,"metadata":{},"sourceType":"module"}