{"ast":null,"code":"import { __decorate } from 'tslib';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { EventEmitter, Component, ChangeDetectionStrategy, ViewEncapsulation, Inject, Optional, ViewChild, Input, Output, NgModule } from '@angular/core';\nimport { Subscription, ReplaySubject, Subject, merge, fromEvent } from 'rxjs';\nimport { takeUntil, map, throttleTime } from 'rxjs/operators';\nimport * as i1 from 'ng-zorro-antd/core/config';\nimport { WithConfig } from 'ng-zorro-antd/core/config';\nimport { shallowEqual, getStyleAsText, InputNumber } from 'ng-zorro-antd/core/util';\nimport * as i2 from 'ng-zorro-antd/core/services';\nimport * as i3 from '@angular/cdk/platform';\nimport { PlatformModule } from '@angular/cdk/platform';\nimport * as i4 from 'ng-zorro-antd/cdk/resize-observer';\nimport * as i5 from '@angular/cdk/bidi';\nimport { BidiModule } from '@angular/cdk/bidi';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nconst _c0 = [\"fixedEl\"];\nconst _c1 = [\"*\"];\nvar AffixRespondEvents = /*#__PURE__*/(() => {\n  (function (AffixRespondEvents) {\n    AffixRespondEvents[\"resize\"] = \"resize\";\n    AffixRespondEvents[\"scroll\"] = \"scroll\";\n    AffixRespondEvents[\"touchstart\"] = \"touchstart\";\n    AffixRespondEvents[\"touchmove\"] = \"touchmove\";\n    AffixRespondEvents[\"touchend\"] = \"touchend\";\n    AffixRespondEvents[\"pageshow\"] = \"pageshow\";\n    AffixRespondEvents[\"load\"] = \"LOAD\";\n  })(AffixRespondEvents || (AffixRespondEvents = {}));\n\n  return AffixRespondEvents;\n})();\n\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\nfunction isTargetWindow(target) {\n  return typeof window !== 'undefined' && target === window;\n}\n\nfunction getTargetRect(target) {\n  return !isTargetWindow(target) ? target.getBoundingClientRect() : {\n    top: 0,\n    left: 0,\n    bottom: 0\n  };\n}\n\nconst NZ_CONFIG_MODULE_NAME = 'affix';\nconst NZ_AFFIX_CLS_PREFIX = 'ant-affix';\nconst NZ_AFFIX_DEFAULT_SCROLL_TIME = 20;\nlet NzAffixComponent = /*#__PURE__*/(() => {\n  class NzAffixComponent {\n    constructor(el, doc, nzConfigService, scrollSrv, ngZone, platform, renderer, nzResizeObserver, cdr, directionality) {\n      this.nzConfigService = nzConfigService;\n      this.scrollSrv = scrollSrv;\n      this.ngZone = ngZone;\n      this.platform = platform;\n      this.renderer = renderer;\n      this.nzResizeObserver = nzResizeObserver;\n      this.cdr = cdr;\n      this.directionality = directionality;\n      this._nzModuleName = NZ_CONFIG_MODULE_NAME;\n      this.nzChange = new EventEmitter();\n      this.dir = 'ltr';\n      this.positionChangeSubscription = Subscription.EMPTY;\n      this.offsetChanged$ = new ReplaySubject(1);\n      this.destroy$ = new Subject(); // The wrapper would stay at the original position as a placeholder.\n\n      this.placeholderNode = el.nativeElement;\n      this.document = doc;\n    }\n\n    get target() {\n      const el = this.nzTarget;\n      return (typeof el === 'string' ? this.document.querySelector(el) : el) || window;\n    }\n\n    ngOnInit() {\n      var _a;\n\n      (_a = this.directionality.change) === null || _a === void 0 ? void 0 : _a.pipe(takeUntil(this.destroy$)).subscribe(direction => {\n        this.dir = direction;\n        this.registerListeners();\n        this.updatePosition({});\n        this.cdr.detectChanges();\n      });\n      this.dir = this.directionality.value;\n    }\n\n    ngOnChanges(changes) {\n      const {\n        nzOffsetBottom,\n        nzOffsetTop,\n        nzTarget\n      } = changes;\n\n      if (nzOffsetBottom || nzOffsetTop) {\n        this.offsetChanged$.next();\n      }\n\n      if (nzTarget) {\n        this.registerListeners();\n      }\n    }\n\n    ngAfterViewInit() {\n      this.registerListeners();\n    }\n\n    ngOnDestroy() {\n      this.removeListeners();\n    }\n\n    registerListeners() {\n      if (!this.platform.isBrowser) {\n        return;\n      }\n\n      this.removeListeners();\n      const el = this.target === window ? this.document.body : this.target;\n      this.positionChangeSubscription = this.ngZone.runOutsideAngular(() => merge(...Object.keys(AffixRespondEvents).map(evName => fromEvent(this.target, evName)), this.offsetChanged$.pipe(map(() => ({}))), this.nzResizeObserver.observe(el)).pipe(throttleTime(NZ_AFFIX_DEFAULT_SCROLL_TIME, undefined, {\n        trailing: true\n      }), takeUntil(this.destroy$)).subscribe(e => this.updatePosition(e)));\n      this.timeout = setTimeout(() => this.updatePosition({}));\n    }\n\n    removeListeners() {\n      clearTimeout(this.timeout);\n      this.positionChangeSubscription.unsubscribe();\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n    getOffset(element, target) {\n      const elemRect = element.getBoundingClientRect();\n      const targetRect = getTargetRect(target);\n      const scrollTop = this.scrollSrv.getScroll(target, true);\n      const scrollLeft = this.scrollSrv.getScroll(target, false);\n      const docElem = this.document.body;\n      const clientTop = docElem.clientTop || 0;\n      const clientLeft = docElem.clientLeft || 0;\n      return {\n        top: elemRect.top - targetRect.top + scrollTop - clientTop,\n        left: elemRect.left - targetRect.left + scrollLeft - clientLeft,\n        width: elemRect.width,\n        height: elemRect.height\n      };\n    }\n\n    setAffixStyle(e, affixStyle) {\n      const originalAffixStyle = this.affixStyle;\n      const isWindow = this.target === window;\n\n      if (e.type === 'scroll' && originalAffixStyle && affixStyle && isWindow) {\n        return;\n      }\n\n      if (shallowEqual(originalAffixStyle, affixStyle)) {\n        return;\n      }\n\n      const fixed = !!affixStyle;\n      const wrapEl = this.fixedEl.nativeElement;\n      this.renderer.setStyle(wrapEl, 'cssText', getStyleAsText(affixStyle));\n      this.affixStyle = affixStyle;\n\n      if (fixed) {\n        wrapEl.classList.add(NZ_AFFIX_CLS_PREFIX);\n      } else {\n        wrapEl.classList.remove(NZ_AFFIX_CLS_PREFIX);\n      }\n\n      this.updateRtlClass();\n\n      if (affixStyle && !originalAffixStyle || !affixStyle && originalAffixStyle) {\n        this.nzChange.emit(fixed);\n      }\n    }\n\n    setPlaceholderStyle(placeholderStyle) {\n      const originalPlaceholderStyle = this.placeholderStyle;\n\n      if (shallowEqual(placeholderStyle, originalPlaceholderStyle)) {\n        return;\n      }\n\n      this.renderer.setStyle(this.placeholderNode, 'cssText', getStyleAsText(placeholderStyle));\n      this.placeholderStyle = placeholderStyle;\n    }\n\n    syncPlaceholderStyle(e) {\n      if (!this.affixStyle) {\n        return;\n      }\n\n      this.renderer.setStyle(this.placeholderNode, 'cssText', '');\n      this.placeholderStyle = undefined;\n      const styleObj = {\n        width: this.placeholderNode.offsetWidth,\n        height: this.fixedEl.nativeElement.offsetHeight\n      };\n      this.setAffixStyle(e, Object.assign(Object.assign({}, this.affixStyle), styleObj));\n      this.setPlaceholderStyle(styleObj);\n    }\n\n    updatePosition(e) {\n      if (!this.platform.isBrowser) {\n        return;\n      }\n\n      const targetNode = this.target;\n      let offsetTop = this.nzOffsetTop;\n      const scrollTop = this.scrollSrv.getScroll(targetNode, true);\n      const elemOffset = this.getOffset(this.placeholderNode, targetNode);\n      const fixedNode = this.fixedEl.nativeElement;\n      const elemSize = {\n        width: fixedNode.offsetWidth,\n        height: fixedNode.offsetHeight\n      };\n      const offsetMode = {\n        top: false,\n        bottom: false\n      }; // Default to `offsetTop=0`.\n\n      if (typeof offsetTop !== 'number' && typeof this.nzOffsetBottom !== 'number') {\n        offsetMode.top = true;\n        offsetTop = 0;\n      } else {\n        offsetMode.top = typeof offsetTop === 'number';\n        offsetMode.bottom = typeof this.nzOffsetBottom === 'number';\n      }\n\n      const targetRect = getTargetRect(targetNode);\n      const targetInnerHeight = targetNode.innerHeight || targetNode.clientHeight;\n\n      if (scrollTop >= elemOffset.top - offsetTop && offsetMode.top) {\n        const width = elemOffset.width;\n        const top = targetRect.top + offsetTop;\n        this.setAffixStyle(e, {\n          position: 'fixed',\n          top,\n          left: targetRect.left + elemOffset.left,\n          width\n        });\n        this.setPlaceholderStyle({\n          width,\n          height: elemSize.height\n        });\n      } else if (scrollTop <= elemOffset.top + elemSize.height + this.nzOffsetBottom - targetInnerHeight && offsetMode.bottom) {\n        const targetBottomOffset = targetNode === window ? 0 : window.innerHeight - targetRect.bottom;\n        const width = elemOffset.width;\n        this.setAffixStyle(e, {\n          position: 'fixed',\n          bottom: targetBottomOffset + this.nzOffsetBottom,\n          left: targetRect.left + elemOffset.left,\n          width\n        });\n        this.setPlaceholderStyle({\n          width,\n          height: elemOffset.height\n        });\n      } else {\n        if (e.type === AffixRespondEvents.resize && this.affixStyle && this.affixStyle.position === 'fixed' && this.placeholderNode.offsetWidth) {\n          this.setAffixStyle(e, Object.assign(Object.assign({}, this.affixStyle), {\n            width: this.placeholderNode.offsetWidth\n          }));\n        } else {\n          this.setAffixStyle(e);\n        }\n\n        this.setPlaceholderStyle();\n      }\n\n      if (e.type === 'resize') {\n        this.syncPlaceholderStyle(e);\n      }\n    }\n\n    updateRtlClass() {\n      const wrapEl = this.fixedEl.nativeElement;\n\n      if (this.dir === 'rtl') {\n        if (wrapEl.classList.contains(NZ_AFFIX_CLS_PREFIX)) {\n          wrapEl.classList.add(`${NZ_AFFIX_CLS_PREFIX}-rtl`);\n        } else {\n          wrapEl.classList.remove(`${NZ_AFFIX_CLS_PREFIX}-rtl`);\n        }\n      } else {\n        wrapEl.classList.remove(`${NZ_AFFIX_CLS_PREFIX}-rtl`);\n      }\n    }\n\n  }\n\n  NzAffixComponent.ɵfac = function NzAffixComponent_Factory(t) {\n    return new (t || NzAffixComponent)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DOCUMENT), i0.ɵɵdirectiveInject(i1.NzConfigService), i0.ɵɵdirectiveInject(i2.NzScrollService), i0.ɵɵdirectiveInject(i0.NgZone), i0.ɵɵdirectiveInject(i3.Platform), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i4.NzResizeObserver), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef), i0.ɵɵdirectiveInject(i5.Directionality, 8));\n  };\n\n  NzAffixComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NzAffixComponent,\n    selectors: [[\"nz-affix\"]],\n    viewQuery: function NzAffixComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵviewQuery(_c0, 7);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.fixedEl = _t.first);\n      }\n    },\n    inputs: {\n      nzTarget: \"nzTarget\",\n      nzOffsetTop: \"nzOffsetTop\",\n      nzOffsetBottom: \"nzOffsetBottom\"\n    },\n    outputs: {\n      nzChange: \"nzChange\"\n    },\n    exportAs: [\"nzAffix\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c1,\n    decls: 3,\n    vars: 0,\n    consts: [[\"fixedEl\", \"\"]],\n    template: function NzAffixComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", null, 0);\n        i0.ɵɵprojection(2);\n        i0.ɵɵelementEnd();\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([WithConfig(), InputNumber(undefined)], NzAffixComponent.prototype, \"nzOffsetTop\", void 0);\n\n  __decorate([WithConfig(), InputNumber(undefined)], NzAffixComponent.prototype, \"nzOffsetBottom\", void 0);\n\n  return NzAffixComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzAffixModule = /*#__PURE__*/(() => {\n  class NzAffixModule {}\n\n  NzAffixModule.ɵfac = function NzAffixModule_Factory(t) {\n    return new (t || NzAffixModule)();\n  };\n\n  NzAffixModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NzAffixModule\n  });\n  NzAffixModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[BidiModule, CommonModule, PlatformModule]]\n  });\n  return NzAffixModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { NzAffixComponent, NzAffixModule }; //# sourceMappingURL=ng-zorro-antd-affix.mjs.map","map":null,"metadata":{},"sourceType":"module"}