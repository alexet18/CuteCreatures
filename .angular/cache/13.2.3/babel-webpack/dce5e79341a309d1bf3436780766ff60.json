{"ast":null,"code":"import * as i2$1 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport * as i0 from '@angular/core';\nimport { Injectable, Inject, EventEmitter, Directive, Input, Output, Component, ChangeDetectionStrategy, NgModule } from '@angular/core';\nimport { __decorate } from 'tslib';\nimport { Subject, fromEvent } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nimport { isTouchEvent, ensureInBounds, InputBoolean } from 'ng-zorro-antd/core/util';\nimport * as i2 from '@angular/cdk/platform';\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\nconst _c0 = [\"*\"];\n\nfunction NzResizeHandlesComponent_nz_resize_handle_0_Template(rf, ctx) {\n  if (rf & 1) {\n    i0.ɵɵelement(0, \"nz-resize-handle\", 1);\n  }\n\n  if (rf & 2) {\n    const dir_r1 = ctx.$implicit;\n    i0.ɵɵproperty(\"nzDirection\", dir_r1);\n  }\n}\n\nfunction getEventWithPoint(event) {\n  return isTouchEvent(event) ? event.touches[0] || event.changedTouches[0] : event;\n}\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzResizableService = /*#__PURE__*/(() => {\n  class NzResizableService {\n    constructor(ngZone, document) {\n      this.ngZone = ngZone;\n      this.listeners = new Map();\n      this.handleMouseDown$ = new Subject();\n      this.documentMouseUp$ = new Subject();\n      this.documentMouseMove$ = new Subject();\n      this.mouseEntered$ = new Subject();\n      this.document = document;\n    }\n\n    startResizing(event) {\n      const _isTouchEvent = isTouchEvent(event);\n\n      this.clearListeners();\n      const moveEvent = _isTouchEvent ? 'touchmove' : 'mousemove';\n      const upEvent = _isTouchEvent ? 'touchend' : 'mouseup';\n\n      const moveEventHandler = e => {\n        this.documentMouseMove$.next(e);\n      };\n\n      const upEventHandler = e => {\n        this.documentMouseUp$.next(e);\n        this.clearListeners();\n      };\n\n      this.listeners.set(moveEvent, moveEventHandler);\n      this.listeners.set(upEvent, upEventHandler);\n      this.ngZone.runOutsideAngular(() => {\n        this.listeners.forEach((handler, name) => {\n          this.document.addEventListener(name, handler);\n        });\n      });\n    }\n\n    clearListeners() {\n      this.listeners.forEach((handler, name) => {\n        this.document.removeEventListener(name, handler);\n      });\n      this.listeners.clear();\n    }\n\n    ngOnDestroy() {\n      this.handleMouseDown$.complete();\n      this.documentMouseUp$.complete();\n      this.documentMouseMove$.complete();\n      this.mouseEntered$.complete();\n      this.clearListeners();\n    }\n\n  }\n\n  NzResizableService.ɵfac = function NzResizableService_Factory(t) {\n    return new (t || NzResizableService)(i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(DOCUMENT));\n  };\n\n  NzResizableService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NzResizableService,\n    factory: NzResizableService.ɵfac\n  });\n  return NzResizableService;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet NzResizableDirective = /*#__PURE__*/(() => {\n  class NzResizableDirective {\n    constructor(elementRef, renderer, nzResizableService, platform, ngZone) {\n      this.elementRef = elementRef;\n      this.renderer = renderer;\n      this.nzResizableService = nzResizableService;\n      this.platform = platform;\n      this.ngZone = ngZone;\n      this.nzBounds = 'parent';\n      this.nzMinHeight = 40;\n      this.nzMinWidth = 40;\n      this.nzGridColumnCount = -1;\n      this.nzMaxColumn = -1;\n      this.nzMinColumn = -1;\n      this.nzLockAspectRatio = false;\n      this.nzPreview = false;\n      this.nzDisabled = false;\n      this.nzResize = new EventEmitter();\n      this.nzResizeEnd = new EventEmitter();\n      this.nzResizeStart = new EventEmitter();\n      this.resizing = false;\n      this.currentHandleEvent = null;\n      this.ghostElement = null;\n      this.sizeCache = null;\n      this.destroy$ = new Subject();\n      this.nzResizableService.handleMouseDown$.pipe(takeUntil(this.destroy$)).subscribe(event => {\n        if (this.nzDisabled) {\n          return;\n        }\n\n        this.resizing = true;\n        this.nzResizableService.startResizing(event.mouseEvent);\n        this.currentHandleEvent = event;\n        this.setCursor();\n        this.nzResizeStart.emit({\n          mouseEvent: event.mouseEvent\n        });\n        this.elRect = this.el.getBoundingClientRect();\n      });\n      this.nzResizableService.documentMouseUp$.pipe(takeUntil(this.destroy$)).subscribe(event => {\n        if (this.resizing) {\n          this.resizing = false;\n          this.nzResizableService.documentMouseUp$.next();\n          this.endResize(event);\n        }\n      });\n      this.nzResizableService.documentMouseMove$.pipe(takeUntil(this.destroy$)).subscribe(event => {\n        if (this.resizing) {\n          this.resize(event);\n        }\n      });\n    }\n\n    setPosition() {\n      const position = getComputedStyle(this.el).position;\n\n      if (position === 'static' || !position) {\n        this.renderer.setStyle(this.el, 'position', 'relative');\n      }\n    }\n\n    calcSize(width, height, ratio) {\n      let newWidth;\n      let newHeight;\n      let maxWidth;\n      let maxHeight;\n      let col = 0;\n      let spanWidth = 0;\n      let minWidth = this.nzMinWidth;\n      let boundWidth = Infinity;\n      let boundHeight = Infinity;\n\n      if (this.nzBounds === 'parent') {\n        const parent = this.renderer.parentNode(this.el);\n\n        if (parent instanceof HTMLElement) {\n          const parentRect = parent.getBoundingClientRect();\n          boundWidth = parentRect.width;\n          boundHeight = parentRect.height;\n        }\n      } else if (this.nzBounds === 'window') {\n        if (typeof window !== 'undefined') {\n          boundWidth = window.innerWidth;\n          boundHeight = window.innerHeight;\n        }\n      } else if (this.nzBounds && this.nzBounds.nativeElement && this.nzBounds.nativeElement instanceof HTMLElement) {\n        const boundsRect = this.nzBounds.nativeElement.getBoundingClientRect();\n        boundWidth = boundsRect.width;\n        boundHeight = boundsRect.height;\n      }\n\n      maxWidth = ensureInBounds(this.nzMaxWidth, boundWidth);\n      maxHeight = ensureInBounds(this.nzMaxHeight, boundHeight);\n\n      if (this.nzGridColumnCount !== -1) {\n        spanWidth = maxWidth / this.nzGridColumnCount;\n        minWidth = this.nzMinColumn !== -1 ? spanWidth * this.nzMinColumn : minWidth;\n        maxWidth = this.nzMaxColumn !== -1 ? spanWidth * this.nzMaxColumn : maxWidth;\n      }\n\n      if (ratio !== -1) {\n        if (/(left|right)/i.test(this.currentHandleEvent.direction)) {\n          newWidth = Math.min(Math.max(width, minWidth), maxWidth);\n          newHeight = Math.min(Math.max(newWidth / ratio, this.nzMinHeight), maxHeight);\n\n          if (newHeight >= maxHeight || newHeight <= this.nzMinHeight) {\n            newWidth = Math.min(Math.max(newHeight * ratio, minWidth), maxWidth);\n          }\n        } else {\n          newHeight = Math.min(Math.max(height, this.nzMinHeight), maxHeight);\n          newWidth = Math.min(Math.max(newHeight * ratio, minWidth), maxWidth);\n\n          if (newWidth >= maxWidth || newWidth <= minWidth) {\n            newHeight = Math.min(Math.max(newWidth / ratio, this.nzMinHeight), maxHeight);\n          }\n        }\n      } else {\n        newWidth = Math.min(Math.max(width, minWidth), maxWidth);\n        newHeight = Math.min(Math.max(height, this.nzMinHeight), maxHeight);\n      }\n\n      if (this.nzGridColumnCount !== -1) {\n        col = Math.round(newWidth / spanWidth);\n        newWidth = col * spanWidth;\n      }\n\n      return {\n        col,\n        width: newWidth,\n        height: newHeight\n      };\n    }\n\n    setCursor() {\n      switch (this.currentHandleEvent.direction) {\n        case 'left':\n        case 'right':\n          this.renderer.setStyle(document.body, 'cursor', 'ew-resize');\n          break;\n\n        case 'top':\n        case 'bottom':\n          this.renderer.setStyle(document.body, 'cursor', 'ns-resize');\n          break;\n\n        case 'topLeft':\n        case 'bottomRight':\n          this.renderer.setStyle(document.body, 'cursor', 'nwse-resize');\n          break;\n\n        case 'topRight':\n        case 'bottomLeft':\n          this.renderer.setStyle(document.body, 'cursor', 'nesw-resize');\n          break;\n      }\n\n      this.renderer.setStyle(document.body, 'user-select', 'none');\n    }\n\n    resize(event) {\n      const elRect = this.elRect;\n      const resizeEvent = getEventWithPoint(event);\n      const handleEvent = getEventWithPoint(this.currentHandleEvent.mouseEvent);\n      let width = elRect.width;\n      let height = elRect.height;\n      const ratio = this.nzLockAspectRatio ? width / height : -1;\n\n      switch (this.currentHandleEvent.direction) {\n        case 'bottomRight':\n          width = resizeEvent.clientX - elRect.left;\n          height = resizeEvent.clientY - elRect.top;\n          break;\n\n        case 'bottomLeft':\n          width = elRect.width + handleEvent.clientX - resizeEvent.clientX;\n          height = resizeEvent.clientY - elRect.top;\n          break;\n\n        case 'topRight':\n          width = resizeEvent.clientX - elRect.left;\n          height = elRect.height + handleEvent.clientY - resizeEvent.clientY;\n          break;\n\n        case 'topLeft':\n          width = elRect.width + handleEvent.clientX - resizeEvent.clientX;\n          height = elRect.height + handleEvent.clientY - resizeEvent.clientY;\n          break;\n\n        case 'top':\n          height = elRect.height + handleEvent.clientY - resizeEvent.clientY;\n          break;\n\n        case 'right':\n          width = resizeEvent.clientX - elRect.left;\n          break;\n\n        case 'bottom':\n          height = resizeEvent.clientY - elRect.top;\n          break;\n\n        case 'left':\n          width = elRect.width + handleEvent.clientX - resizeEvent.clientX;\n      }\n\n      const size = this.calcSize(width, height, ratio);\n      this.sizeCache = Object.assign({}, size); // Re-enter the Angular zone and run the change detection only if there're any `nzResize` listeners,\n      // e.g.: `<div nz-resizable (nzResize)=\"...\"></div>`.\n\n      if (this.nzResize.observers.length) {\n        this.ngZone.run(() => {\n          this.nzResize.emit(Object.assign(Object.assign({}, size), {\n            mouseEvent: event\n          }));\n        });\n      }\n\n      if (this.nzPreview) {\n        this.previewResize(size);\n      }\n    }\n\n    endResize(event) {\n      this.renderer.setStyle(document.body, 'cursor', '');\n      this.renderer.setStyle(document.body, 'user-select', '');\n      this.removeGhostElement();\n      const size = this.sizeCache ? Object.assign({}, this.sizeCache) : {\n        width: this.elRect.width,\n        height: this.elRect.height\n      }; // Re-enter the Angular zone and run the change detection only if there're any `nzResizeEnd` listeners,\n      // e.g.: `<div nz-resizable (nzResizeEnd)=\"...\"></div>`.\n\n      if (this.nzResizeEnd.observers.length) {\n        this.ngZone.run(() => {\n          this.nzResizeEnd.emit(Object.assign(Object.assign({}, size), {\n            mouseEvent: event\n          }));\n        });\n      }\n\n      this.sizeCache = null;\n      this.currentHandleEvent = null;\n    }\n\n    previewResize({\n      width,\n      height\n    }) {\n      this.createGhostElement();\n      this.renderer.setStyle(this.ghostElement, 'width', `${width}px`);\n      this.renderer.setStyle(this.ghostElement, 'height', `${height}px`);\n    }\n\n    createGhostElement() {\n      if (!this.ghostElement) {\n        this.ghostElement = this.renderer.createElement('div');\n        this.renderer.setAttribute(this.ghostElement, 'class', 'nz-resizable-preview');\n      }\n\n      this.renderer.appendChild(this.el, this.ghostElement);\n    }\n\n    removeGhostElement() {\n      if (this.ghostElement) {\n        this.renderer.removeChild(this.el, this.ghostElement);\n      }\n    }\n\n    ngAfterViewInit() {\n      if (!this.platform.isBrowser) {\n        return;\n      }\n\n      this.el = this.elementRef.nativeElement;\n      this.setPosition();\n      this.ngZone.runOutsideAngular(() => {\n        fromEvent(this.el, 'mouseenter').pipe(takeUntil(this.destroy$)).subscribe(() => {\n          this.nzResizableService.mouseEntered$.next(true);\n        });\n        fromEvent(this.el, 'mouseleave').pipe(takeUntil(this.destroy$)).subscribe(() => {\n          this.nzResizableService.mouseEntered$.next(false);\n        });\n      });\n    }\n\n    ngOnDestroy() {\n      this.ghostElement = null;\n      this.sizeCache = null;\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n  }\n\n  NzResizableDirective.ɵfac = function NzResizableDirective_Factory(t) {\n    return new (t || NzResizableDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(NzResizableService), i0.ɵɵdirectiveInject(i2.Platform), i0.ɵɵdirectiveInject(i0.NgZone));\n  };\n\n  NzResizableDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: NzResizableDirective,\n    selectors: [[\"\", \"nz-resizable\", \"\"]],\n    hostAttrs: [1, \"nz-resizable\"],\n    hostVars: 4,\n    hostBindings: function NzResizableDirective_HostBindings(rf, ctx) {\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"nz-resizable-resizing\", ctx.resizing)(\"nz-resizable-disabled\", ctx.nzDisabled);\n      }\n    },\n    inputs: {\n      nzBounds: \"nzBounds\",\n      nzMaxHeight: \"nzMaxHeight\",\n      nzMaxWidth: \"nzMaxWidth\",\n      nzMinHeight: \"nzMinHeight\",\n      nzMinWidth: \"nzMinWidth\",\n      nzGridColumnCount: \"nzGridColumnCount\",\n      nzMaxColumn: \"nzMaxColumn\",\n      nzMinColumn: \"nzMinColumn\",\n      nzLockAspectRatio: \"nzLockAspectRatio\",\n      nzPreview: \"nzPreview\",\n      nzDisabled: \"nzDisabled\"\n    },\n    outputs: {\n      nzResize: \"nzResize\",\n      nzResizeEnd: \"nzResizeEnd\",\n      nzResizeStart: \"nzResizeStart\"\n    },\n    exportAs: [\"nzResizable\"],\n    features: [i0.ɵɵProvidersFeature([NzResizableService])]\n  });\n\n  __decorate([InputBoolean()], NzResizableDirective.prototype, \"nzLockAspectRatio\", void 0);\n\n  __decorate([InputBoolean()], NzResizableDirective.prototype, \"nzPreview\", void 0);\n\n  __decorate([InputBoolean()], NzResizableDirective.prototype, \"nzDisabled\", void 0);\n\n  return NzResizableDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nclass NzResizeHandleMouseDownEvent {\n  constructor(direction, mouseEvent) {\n    this.direction = direction;\n    this.mouseEvent = mouseEvent;\n  }\n\n}\n\nlet NzResizeHandleComponent = /*#__PURE__*/(() => {\n  class NzResizeHandleComponent {\n    constructor(nzResizableService, renderer, elementRef) {\n      this.nzResizableService = nzResizableService;\n      this.renderer = renderer;\n      this.elementRef = elementRef;\n      this.nzDirection = 'bottomRight';\n      this.nzMouseDown = new EventEmitter();\n      this.destroy$ = new Subject();\n    }\n\n    ngOnInit() {\n      // Caretaker note: `mouseEntered$` subject will emit events within the `<root>` zone,\n      // see `NzResizableDirective#ngAfterViewInit`. There're event listeners are added within the `<root>` zone.\n      this.nzResizableService.mouseEntered$.pipe(takeUntil(this.destroy$)).subscribe(entered => {\n        if (entered) {\n          this.renderer.addClass(this.elementRef.nativeElement, 'nz-resizable-handle-box-hover');\n        } else {\n          this.renderer.removeClass(this.elementRef.nativeElement, 'nz-resizable-handle-box-hover');\n        }\n      });\n    }\n\n    onMousedown(event) {\n      this.nzResizableService.handleMouseDown$.next(new NzResizeHandleMouseDownEvent(this.nzDirection, event));\n    }\n\n    ngOnDestroy() {\n      this.destroy$.next();\n      this.destroy$.complete();\n    }\n\n  }\n\n  NzResizeHandleComponent.ɵfac = function NzResizeHandleComponent_Factory(t) {\n    return new (t || NzResizeHandleComponent)(i0.ɵɵdirectiveInject(NzResizableService), i0.ɵɵdirectiveInject(i0.Renderer2), i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  NzResizeHandleComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NzResizeHandleComponent,\n    selectors: [[\"nz-resize-handle\"], [\"\", \"nz-resize-handle\", \"\"]],\n    hostAttrs: [1, \"nz-resizable-handle\"],\n    hostVars: 16,\n    hostBindings: function NzResizeHandleComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"mousedown\", function NzResizeHandleComponent_mousedown_HostBindingHandler($event) {\n          return ctx.onMousedown($event);\n        })(\"touchstart\", function NzResizeHandleComponent_touchstart_HostBindingHandler($event) {\n          return ctx.onMousedown($event);\n        });\n      }\n\n      if (rf & 2) {\n        i0.ɵɵclassProp(\"nz-resizable-handle-top\", ctx.nzDirection === \"top\")(\"nz-resizable-handle-right\", ctx.nzDirection === \"right\")(\"nz-resizable-handle-bottom\", ctx.nzDirection === \"bottom\")(\"nz-resizable-handle-left\", ctx.nzDirection === \"left\")(\"nz-resizable-handle-topRight\", ctx.nzDirection === \"topRight\")(\"nz-resizable-handle-bottomRight\", ctx.nzDirection === \"bottomRight\")(\"nz-resizable-handle-bottomLeft\", ctx.nzDirection === \"bottomLeft\")(\"nz-resizable-handle-topLeft\", ctx.nzDirection === \"topLeft\");\n      }\n    },\n    inputs: {\n      nzDirection: \"nzDirection\"\n    },\n    outputs: {\n      nzMouseDown: \"nzMouseDown\"\n    },\n    exportAs: [\"nzResizeHandle\"],\n    ngContentSelectors: _c0,\n    decls: 1,\n    vars: 0,\n    template: function NzResizeHandleComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵprojection(0);\n      }\n    },\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return NzResizeHandleComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nconst DEFAULT_RESIZE_DIRECTION = ['bottomRight', 'topRight', 'bottomLeft', 'topLeft', 'bottom', 'right', 'top', 'left'];\nlet NzResizeHandlesComponent = /*#__PURE__*/(() => {\n  class NzResizeHandlesComponent {\n    constructor() {\n      this.nzDirections = DEFAULT_RESIZE_DIRECTION;\n      this.directions = new Set(this.nzDirections);\n    }\n\n    ngOnChanges(changes) {\n      if (changes.nzDirections) {\n        this.directions = new Set(changes.nzDirections.currentValue);\n      }\n    }\n\n  }\n\n  NzResizeHandlesComponent.ɵfac = function NzResizeHandlesComponent_Factory(t) {\n    return new (t || NzResizeHandlesComponent)();\n  };\n\n  NzResizeHandlesComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: NzResizeHandlesComponent,\n    selectors: [[\"nz-resize-handles\"]],\n    inputs: {\n      nzDirections: \"nzDirections\"\n    },\n    exportAs: [\"nzResizeHandles\"],\n    features: [i0.ɵɵNgOnChangesFeature],\n    decls: 1,\n    vars: 1,\n    consts: [[3, \"nzDirection\", 4, \"ngFor\", \"ngForOf\"], [3, \"nzDirection\"]],\n    template: function NzResizeHandlesComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵtemplate(0, NzResizeHandlesComponent_nz_resize_handle_0_Template, 1, 1, \"nz-resize-handle\", 0);\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"ngForOf\", ctx.directions);\n      }\n    },\n    directives: [NzResizeHandleComponent, i2$1.NgForOf],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n  return NzResizeHandlesComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n\nlet NzResizableModule = /*#__PURE__*/(() => {\n  class NzResizableModule {}\n\n  NzResizableModule.ɵfac = function NzResizableModule_Factory(t) {\n    return new (t || NzResizableModule)();\n  };\n\n  NzResizableModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: NzResizableModule\n  });\n  NzResizableModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return NzResizableModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://github.com/NG-ZORRO/ng-zorro-antd/blob/master/LICENSE\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { DEFAULT_RESIZE_DIRECTION, NzResizableDirective, NzResizableModule, NzResizableService, NzResizeHandleComponent, NzResizeHandleMouseDownEvent, NzResizeHandlesComponent, getEventWithPoint }; //# sourceMappingURL=ng-zorro-antd-resizable.mjs.map","map":null,"metadata":{},"sourceType":"module"}